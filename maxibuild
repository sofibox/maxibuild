#!/bin/bash
#"=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
# ==================================================
_APP_SPECIFIC_NAME="Maxibuild"
_APP_VERSION="0.2.1"
_APP_STATUS="alpha"
_APP_INFO="${_APP_SPECIFIC_NAME} is a bash script to manage packages."
_APP_VERSION_STATUS="${_APP_VERSION}-${_APP_STATUS}"
_AUTHOR="Author: Arafat Ali | Email: arafat@sofibox.com | (C) 2019-2022"
# ====================================================

# This script is used to update script from a remote repository based on a given path
# Usage: script_update [script_path]
# Example: script_update /opt/maxigpg_public/
script_update() {
  local script_name script_path caller script_install_path current_configs new_configs

  script_name="$(basename "${0}")"
  script_path="$(dirname "$(readlink -f "$0")")"
  caller="${script_name}->${FUNCNAME[0]}"
  script_install_path="${1}"

  echo "[${caller}]: Updating $(basename -- "$0") to latest version ..."
  # CD to ${script_path} and if does not exist exit with error
  cd "${script_path}" || {
    echo "[${caller}]: ERROR, could not change directory to ${script_path}"
    exit 1
  }
  echo ""
  echo "START git update information:"
  git fetch --all
  get_status_message "$?"
  git reset --hard origin/main
  get_status_message "$?"
  echo "END git update information:"
  echo ""

  echo "[${caller}]: Updating ${script_name} configuration file ..."

  # This will add a new config variable into the config file if it does not exist
  # It will not disturb variable that already has value. So you do not need to reconfigure the script
  # If config contain invalid value like having no equal sign, it will also replace them with a new variable from sample config

  current_configs=$(grep -E '^[A-Za-z0-9_].+=.+$' "${script_install_path}/${script_name}.conf" | awk -F "=" '{print $1}')
  new_configs=$(grep -E '^[A-Za-z0-9_].+=.+$' "${script_install_path}/${script_name}.conf.sample" | awk -F "=" '{print $1}')

  for new_config in ${new_configs}; do
    if [[ ${current_configs} =~ ${new_config} ]]; then
      :
    else
      echo "Adding new config: ${new_config} into ${script_install_path}/${script_name}.conf"
      echo "${new_config}=\"\"" >>"${script_install_path}/${script_name}.conf"
      get_status_message "$?"
    fi
  done

  # Remove blank lines, comments and sort config file
  grep -E '^[A-Za-z0-9_].+=.+$' "${script_install_path}/${script_name}.conf" | sort >"${script_install_path}/${script_name}.conf_tmp"
  mv "${script_install_path}/${script_name}.conf_tmp" "${script_install_path}/${script_name}.conf"
  get_status_message "$?"

  echo "[${caller}]: Running ${script_name} -V ..."
  chmod +x "${script_install_path}/${script_name}"
  ${script_name} -V
  get_status_message "$?"

}

# This function is used to check for script update. It will also prompt user to update the script if there is a new version available.
# Usage: check_update
# Example: check_update
check_update() {
  local script_name script_path caller temp_file script_install_path
  script_name="$(basename "${0}")"
  script_path="$(dirname "$(readlink -f "$0")")"
  caller="${script_name}->${FUNCNAME[0]}"
  script_install_path="/usr/local/maxicode/maxibuild"
  echo "[${caller}]: Checking ${script_name} for update..."
  temp_file="${TEMP_PATH}/${script_name}"
  # The github raw hosting will not be updated immediately after I push the update to github. Need to wait about 5 minutes
  if ! command -v curl &>/dev/null; then
    [[ "$(get_distro id)" == +(debian|ubuntu|centos|almalinux|rhel) ]] && apt-get install -y curl
  fi
  curl -H 'Cache-Control: no-cache' -so "${temp_file}" "https://raw.githubusercontent.com/sofibox/${script_name}_public/main/${script_name}"
  get_status_message "$?"
  available_version="$(awk -F'=' '/^_APP_VERSION=/{ print $2 }' "${temp_file}" | sed 's/\"//g')"
  this_version="${_APP_VERSION}"
  echo ""
  echo "Installed version is: v${this_version}"
  echo "Online version is: v${available_version}"
  echo ""
  if [[ "ok" == "$(echo | awk "(${available_version} > ${this_version}) { print \"ok\"; }")" ]]; then
    echo "[${caller}]: A new version of ${script_name} is available."

    read -r -p "[${caller}->input]: Do you want to update ${script_name} to version ${available_version}? [default:Y] [Y/n]: " response

    if [[ "$response" =~ ^([yY][eE][sS]|[yY])$ ]]; then
      script_update "${script_install_path}"
    else
      echo "[${caller}->cancel]: Operation aborted!"
      exit 0
    fi

  elif [[ "ok" == "$(echo | awk "(${available_version} == ${this_version}) { print \"ok\"; }")" ]]; then
    echo "[${caller}]: You are using the latest version of ${script_name}."
  else
    echo "[${caller}]: You are using a newer version of ${script_name} than the latest available."
  fi

  rm -f "${temp_file}"
}

# This function is used to check if given package is installed and install the package if it is not installed
# It will not do anything if the required package exist
# Usage: maxibuild [package(s)]
# Example: maxibuild curl wget git
get_status_message() {
  local retval
  retval="$1"
  if [[ "${retval}" -eq 0 ]]; then
    echo " [ OK ]"
  else
    echo " [ FAILED ]"
    exit 1
  fi
}

get_distro() {
  local arg distro_id distro_version distro_codename
  arg="$1"
  if [ -e /etc/os-release ]; then
    distro_id=$(awk -F= '$1 == "ID" {print $2}' /etc/os-release | LC_ALL=C tr '[:upper:]' '[:lower:]' | tr -d "\"")
    distro_version=$(awk -F= '$1 == "VERSION_ID" {print $2}' /etc/os-release | tr -d "\"")
    distro_codename=$(awk -F= '$1 == "VERSION_CODENAME" {print $2}' /etc/os-release | tr -d "\"")

  elif type lsb_release >/dev/null 2>&1; then
    distro_id=$(lsb_release -si | LC_ALL=C tr '[:upper:]' '[:lower:]')
    distro_version=$(lsb_release -sr)
    distro_codename=$(lsb_release -sc)
  else
    distro_id=$(uname -s)
    distro_version=$(uname -r)
    distro_codename=""
  fi
  if [ "${arg}" == "id" ]; then
    echo "${distro_id}"
  elif [ "${arg}" == "version" ]; then
    echo "${distro_version}"
  elif [ "${arg}" == "codename" ]; then
    echo "${distro_codename}"
  fi
}

# This function is used to convert an integer to ordinal number
# Usage: ordinal [number]
# Example: ordinal 1
# Output: 1st
to_ordinal() {
  local integer
  integer="$1"
  case "${integer}" in
  *1[0-9] | *[04-9]) echo "${integer}"th ;;
  *1) echo "${integer}"st ;;
  *2) echo "${integer}"nd ;;
  *3) echo "${integer}"rd ;;
  esac
}

maxibuild() {

  local caller required_cmds retval

  # Convert the arguments received from include_packages to array
  read -ra required_cmds <<<"$(echo "${include_packages}" | tr ',' ' ' | tr -d '"')"

  ((missing_count = 0))
  caller="$(basename -- "$0")->${FUNCNAME[0]}"

  # Loop through the received arguments. Do not quote the array, we want split elements:
  for required_cmd in ${required_cmds[*]}; do

    # Using command to obtain installation status
    command -v "${required_cmd}" >/dev/null
    cmd_status="$?"

    [[ "${force_install}" == "true" ]] && cmd_status=1

    if [[ "${cmd_status}" -eq 1 ]]; then
      ((missing_count++))
      echo ""

      if [[ "${force_install}" == "true" ]]; then
        echo "[${caller}]: Notice, ${required_cmd} will be installed in --force mode"
      else
        echo "[${caller}]: Warning, ${required_cmd} is missing!"
      fi
      echo ""

      # This prevents error if we never run apt-get update when the apt cache is expired
      # When the first missing package is triggered, then we display warning message,
      # and for this first time, we trigger update command to refresh the expired apt cache
      if [ "${missing_count}" -eq 1 ]; then
        echo "[${caller}]: Running system update for the first time ..."
        [[ "$(get_distro id)" == +(debian|ubuntu) ]] && apt-get -qq -y update
        get_status_message "$?"
        echo ""

        # Check if git is installed (it is necessary)
        if ! command -v git >/dev/null; then
          echo "[${caller}]: Warning, git is missing!"
          echo ""
          echo "[${caller}]: Installing git ..."
          [[ "$(get_distro id)" == +(debian|ubuntu) ]] && apt-get -qq -y install git
          get_status_message "$?"
          echo ""
        fi
      fi

      echo "[${caller}]: ${missing_count}) Installing the $(to_ordinal "${missing_count}") package: ${required_cmd} ..."
      echo ""

      # Package installation condition here
      if [ "${required_cmd}" == "mail" ]; then
        if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
          apt-get -y install bsd-mailx
        elif [[ "$(get_distro id)" == +(centos|almalinux|rockylinux) ]]; then
          apt-get -y install mail-utils
        fi
        get_status_message "$?"
        echo ""
      elif [ "${required_cmd}" == "ipcalc" ]; then
        if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
          local ipcalc_bin script_install_path
          script_install_path="/usr/local/opencode/ipcalc"
          ipcalc_bin="${script_install_path}/build/ipcalc"

          echo "[${caller}]: Removing the old ipcalc installation ..."
          apt-get -y remove ipcalc
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Removing the old ipcalc directory"
          rm -rf "${script_install_path}" /usr/local/bin/ipcalc /usr/bin/ipcalc
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Install required packages to build ipcalc ..."
          apt-get -y install git gcc meson
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating an installation directory for ipcalc ..."
          mkdir -p "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Cloning the ipcalc repository ..."
          git clone https://github.com/sofibox/ipcalc.git "${script_install_path}"
          get_status_message "$?"
          echo ""

          # Change directory to script_install_path, if failed then exit with a message
          cd "${script_install_path}" || {
            echo "Failed to change directory to ${script_install_path}"
            exit 1
          }

          echo "[${caller}]: Configuring ipcalc build type ..."
          meson setup build --buildtype=release
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Building ipcalc ..."
          ninja -C build
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Giving execution permission to the ipcalc installation script ..."
          chmod +x ${ipcalc_bin}
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating a symbolic link to the ipcalc installation script ..."
          ln -s ${ipcalc_bin} /usr/local/bin
          get_status_message "$?"
          echo ""

          #echo "[${caller}]: Copying sample config file ..."
          #cp "${script_install_path}/ipcalc.conf.sample" "${script_install_path}/ipcalc.conf"
          #echo ""

          # echo "[${caller}]: Running ipcalc --version  ..."
          # ipcalc --version
          # get_status_message "$?"
          # retval=$?

          command -v "${required_cmd}" &>/dev/null
          get_status_message "$?"
        fi
      elif [ "${required_cmd}" == "maxipi" ]; then
        if [[ "$(get_distro id)" == +(debian|ubuntu|centos|almalinux) ]]; then
          local maxipi_bin script_install_path
          script_install_path="/usr/local/maxicode/maxipi"
          maxipi_bin="${script_install_path}/maxipi"

          echo "[${caller}]: Removing the old maxipi directory"
          rm -rf "${script_install_path}" /usr/local/bin/maxipi /usr/bin/maxipi
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Install required packages to build maxipi ..."
          apt-get -y install gcc meson
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating an installation directory for maxipi ..."
          mkdir -p "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Cloning the maxipi repository ..."
          git clone https://github.com/sofibox/maxipi_public.git "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Giving execution permission to the maxipi installation script ..."
          chmod +x ${maxipi_bin}
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating a symbolic link to the maxipi installation script ..."
          ln -s ${maxipi_bin} /usr/local/bin
          get_status_message "$?"
          echo ""

          #echo "[${caller}]: Running maxipi --version  ..."
          #maxipi --version
          #get_status_message "$?"
          #retval=$?

          command -v "${required_cmd}" &>/dev/null
          get_status_message "$?"
        fi
      elif [[ "${required_cmd}" == "maxiaide" ]]; then
        if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
          local maxiaide_bin script_install_path
          script_install_path="/usr/local/maxicode/maxiaide"
          maxiaide_bin="${script_install_path}/maxiaide"

          echo "[${caller}]: Removing aide aide-common..."

          apt-get -y remove aide aide-common
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Purging aide aide-common..."
          apt-get -y purge aide-common
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Removing the old maxiaide directory"
          rm -rf "${script_install_path}" /usr/local/bin/maxiaide /usr/bin/maxiaide

          echo "[${caller}]: Install maxiaide required packages ..."
          apt-get -y install aide
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating an installation directory for maxiaide ..."
          mkdir -p "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Cloning the maxiaide repository ..."
          git clone https://github.com/sofibox/maxiaide_public.git "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Giving execution permission to the maxiaide installation script ..."
          chmod +x ${maxiaide_bin}
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating a symbolic link to the maxiaide installation script ..."
          ln -s ${maxiaide_bin} /usr/local/bin
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Copying sample config file ..."
          cp "${script_install_path}/maxiaide.conf.sample" "${script_install_path}/maxiaide.conf"
          get_status_message "$?"
          echo ""

          #echo "[${caller}]: Running maxiaide --version  ..."
          #maxiaide --version
          #get_status_message "$?"
          #retval=$?

          # Extra steps for Debian
          if [ -f /etc/cron.daily/aide ]; then
            echo "[${caller}]: Removing /etc/cron.daily/aide ..."
            rm -fv /etc/cron.daily/aide
            get_status_message "$?"
          fi

          command -v "${required_cmd}" &>/dev/null
          get_status_message "$?"

        fi
      elif [[ "${required_cmd}" == "maxigpg" ]]; then
        if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
          local maxigpg_bin script_install_path
          script_install_path="/usr/local/maxicode/maxigpg"
          maxigpg_bin="${script_install_path}/maxigpg"

          echo "[${caller}]: Removing GPG ..."
          apt-get -y remove gpg
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Removing the old maxigpg directory"
          rm -rf "${script_install_path}" /usr/local/bin/maxigpg /usr/bin/maxigpg
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Install maxigpg required packages ..."
          apt-get -y install gpg
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating an installation directory for maxigpg ..."
          mkdir -p "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Cloning the maxigpg repository ..."
          git clone https://github.com/sofibox/maxigpg_public.git "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Giving execution permission to the maxigpg installation script ..."
          chmod +x ${maxigpg_bin}
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating a symbolic link to the maxigpg installation script ..."
          ln -s ${maxigpg_bin} /usr/local/bin
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Copying sample config file ..."
          cp "${script_install_path}/maxigpg.conf.sample" "${script_install_path}/maxigpg.conf"
          get_status_message "$?"
          echo ""

          #echo "[${caller}]: Running maxigpg --version  ..."
          #maxigpg --version
          #get_status_message "$?"
          #retval=$?

          command -v "${required_cmd}" &>/dev/null
          get_status_message "$?"

        fi
      elif [[ "${required_cmd}" == "maxiperm" ]]; then
        if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
          local maxiperm_bin perm_bin script_install_path
          script_install_path="/usr/local/maxicode/maxiperm"
          maxiperm_bin="${script_install_path}/maxiperm"
          perm_bin="${script_install_path}/perm"

          echo "[${caller}]: Removing the old maxiperm directory"
          rm -rf "${script_install_path}" /usr/local/bin/maxiperm /usr/bin/maxiperm /usr/local/bin/perm /usr/bin/perm
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating an installation directory for maxiperm ..."
          mkdir -p "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Cloning the maxiperm repository ..."
          git clone https://github.com/sofibox/maxiperm_public.git "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Giving execution permission to the maxiperm installation script ..."
          chmod +x ${maxiperm_bin}
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating a symbolic link to the maxiperm installation script ..."
          ln -s ${maxiperm_bin} /usr/local/bin
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Giving execution permission to the perm installation script ..."
          chmod +x ${perm_bin}
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating a symbolic link to the perm installation script ..."
          ln -s ${perm_bin} /usr/local/bin
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Copying sample config file ..."
          cp "${script_install_path}/maxiperm.conf.sample" "${script_install_path}/maxiperm.conf"
          get_status_message "$?"
          echo ""

          # echo "[${caller}]: Running maxiperm --version  ..."
          # maxiperm --version
          # get_status_message "$?"
          # retval=$?

          command -v "${required_cmd}" &>/dev/null
          get_status_message "$?"
        fi
      elif [[ "${required_cmd}" == "maxida" ]]; then
        if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
          local maxida_bin dacli_bin script_install_path
          script_install_path="/usr/local/maxicode/maxida"
          maxida_bin="${script_install_path}/maxida"
          dacli_bin="${script_install_path}/dacli"

          echo "[${caller}]: Removing the old maxida directory"
          rm -rf "${script_install_path}" /usr/local/bin/maxida /usr/bin/maxida /usr/local/bin/dacli /usr/bin/dacli
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating an installation directory for maxida ..."
          mkdir -p "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Cloning the maxida repository ..."
          git clone https://github.com/sofibox/maxida_public.git "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Giving execution permission to the maxida installation script ..."
          chmod +x ${maxida_bin}
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating a symbolic link to the maxida installation script ..."
          ln -s ${maxida_bin} /usr/local/bin
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Giving execution permission to the dacli installation script ..."
          chmod +x ${dacli_bin}
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating a symbolic link to the dacli installation script ..."
          ln -s ${dacli_bin} /usr/local/bin
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Copying sample config file ..."
          cp "${script_install_path}/maxida.conf.sample" "${script_install_path}/maxida.conf"
          get_status_message "$?"
          echo ""

          # echo "[${caller}]: Running maxida --version  ..."
          # maxida --version
          # get_status_message "$?"
          # retval=$?

          command -v "${required_cmd}" &>/dev/null
          get_status_message "$?"
        fi
      elif [ "${required_cmd}" == "dbxcli" ]; then
        if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
          local dbxcli_bin script_install_path
          script_install_path="/usr/local/opencode/dbxcli"
          dbxcli_bin="${script_install_path}/dbxcli"
          dropbox_uploader_bin="${script_install_path}/dropbox_uploader.sh"

          echo "[${caller}]: Removing the old dbxcli directory"
          rm -rf "${script_install_path}" /usr/local/bin/dbxcli /usr/bin/dbxcli
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating an installation directory for dbxcli ..."
          mkdir -p "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Cloning the dbxcli repository ..."
          git clone https://github.com/sofibox/dbxcli.git "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Giving execution permission to the ${dropbox_uploader_bin} installation script ..."
          chmod +x "${dropbox_uploader_bin}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Giving execution permission to the dbxcli installation script ..."
          chmod +x "${dbxcli_bin}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating a symbolic link to the dbxcli installation script ..."
          ln -s "${dbxcli_bin}" /usr/local/bin
          get_status_message "$?"
          echo ""

          # echo "[${caller}]: Running dbxcli version  ..."
          # dbxcli version
          # get_status_message "$?"
          # retval=$?

          command -v "${required_cmd}" &>/dev/null
          get_status_message "$?"
        fi

      elif [[ "${required_cmd}" == "ip" ]]; then
        [[ "$(get_distro id)" == +(debian|ubuntu) ]] && apt-get -y install iproute2

        command -v "${required_cmd}" &>/dev/null
        get_status_message "$?"
      elif [[ "${required_cmd}" == "pstree" ]]; then
        [[ "$(get_distro id)" == +(debian|ubuntu|centos|almalinux|rockylinux) ]] && apt-get -y install psmisc

        command -v "${required_cmd}" &>/dev/null
        get_status_message "$?"
      elif [[ "${required_cmd}" == +(dig|nslookup) ]]; then
        [[ "$(get_distro id)" == +(debian|ubuntu) ]] && apt-get -y install dnsutils
        [[ "$(get_distro id)" == +(centos|almalinux|rockylinux) ]] && apt-get -y install bind-utils

        command -v "${required_cmd}" &>/dev/null
        get_status_message "$?"
      elif [[ "${required_cmd}" == +(netstat) ]]; then
        [[ "$(get_distro id)" == +(debian|ubuntu|centos|almalinux|rockylinux) ]] && apt-get -y install net-tools

        command -v "${required_cmd}" &>/dev/null
        get_status_message "$?"
      elif [[ "${required_cmd}" == +(puttygen) ]]; then
        [[ "$(get_distro id)" == +(debian|ubuntu|centos|almalinux|rockylinux) ]] && apt-get -y install putty-tools

        command -v "${required_cmd}" &>/dev/null
        get_status_message "$?"
      else
        # Do normal distro installation
        if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
          apt-get -y install "${required_cmd}"

          command -v "${required_cmd}" &>/dev/null
          get_status_message "$?"
        elif [[ "$(get_distro id)" == +(centos|almalinux|rockylinux) ]]; then
          dnf -y install "${required_cmd}"

          command -v "${required_cmd}" &>/dev/null
          get_status_message "$?"
        fi
      fi

    fi

  done

}

declare caller force_install include_packages
caller="$(basename -- "$0")->${FUNCNAME[0]}"

force_install=false
include_packages=""

# If no argument is supplied we quit
if [[ $# -eq 0 ]]; then
  echo "Usage: $(basename -- "$0") [-f] [-i package1,package2,...] [-h]"
  echo "  -f: Force install of packages"
  echo "  -i: Include packages"
  echo "  -h: Show this help"
  exit 1
fi

while [ "$#" -gt 0 ]; do
  case "$1" in
  -h | --help)
    echo "Usage: $(basename -- "$0") [-f] [-i package1,package2,...] [-h]"
    echo "  -f: Force install of packages"
    echo "  -i: Include packages"
    echo "  -h: Show this help"
    exit 0
    ;;
  -v | -V | --version | version)
    echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
    echo ""
    echo "Info: ${_APP_INFO}"
    echo ""
    echo "Version: ${_APP_VERSION_STATUS}"
    echo ""
    echo "${_AUTHOR}"
    echo ""
    echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
    exit $?
    ;;
  -f | --force-install)
    force_install=true
    shift
    ;;
  -i | -l | -p | --include | --list | --packages)
    include_packages="$2"
    shift 2
    ;;
  -u | --update | update)
    check_update
    exit $?
    ;;
  --)
    break
    ;;
  *)
    echo "[${caller}]: Error, invalid  or option [ $1 ]. Use --help to see the valid actions or options"
    exit 1

    ;;
  esac

done

maxibuild "$@"
