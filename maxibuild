#!/bin/bash
#"=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
# ==================================================
_APP_SPECIFIC_NAME="Maxibuild"
_APP_VERSION="0.3.0"
_APP_STATUS="alpha"
_APP_INFO="${_APP_SPECIFIC_NAME} is a bash script to manage packages."
_APP_VERSION_STATUS="${_APP_VERSION}-${_APP_STATUS}"
_AUTHOR="Author: Arafat Ali | Email: arafat@sofibox.com | (C) 2019-2022"
# ====================================================
# Usage:
# maxibuild --include-packages "p1 p2 p3 p4" --include-commands "c1 c2 c3 c4" --force

# This script is used to update script from a remote repository based on a given path
# Usage: script_update [script_path]
# Example: script_update /opt/maxigpg_public/
script_update() {
  local script_name script_path caller script_install_path current_configs new_configs

  script_name="$(basename "${0}")"
  script_path="$(dirname "$(readlink -f "$0")")"
  caller="${script_name}->${FUNCNAME[0]}"
  script_install_path="${1}"

  echo "[${caller}]: Updating $(basename -- "$0") to latest version ..."
  # CD to ${script_path} and if does not exist exit with error
  cd "${script_path}" || {
    echo "[${caller}]: ERROR, could not change directory to ${script_path}"
    exit 1
  }
  echo ""
  echo "START git update information:"
  git fetch --all
  get_status_message "$?"
  git reset --hard origin/main
  get_status_message "$?"
  echo "END git update information:"
  echo ""

  echo "[${caller}]: Updating ${script_name} configuration file ..."

  # This will add a new config variable into the config file if it does not exist
  # It will not disturb variable that already has value. So you do not need to reconfigure the script
  # If config contain invalid value like having no equal sign, it will also replace them with a new variable from sample config

  current_configs=$(grep -E '^[A-Za-z0-9_].+=.+$' "${script_install_path}/${script_name}.conf" | awk -F "=" '{print $1}')
  new_configs=$(grep -E '^[A-Za-z0-9_].+=.+$' "${script_install_path}/${script_name}.conf.sample" | awk -F "=" '{print $1}')

  for new_config in ${new_configs}; do
    if [[ ${current_configs} =~ ${new_config} ]]; then
      :
    else
      echo "Adding new config: ${new_config} into ${script_install_path}/${script_name}.conf"
      echo "${new_config}=\"\"" >>"${script_install_path}/${script_name}.conf"
      get_status_message "$?"
    fi
  done

  # Remove blank lines, comments and sort config file
  grep -E '^[A-Za-z0-9_].+=.+$' "${script_install_path}/${script_name}.conf" | sort >"${script_install_path}/${script_name}.conf_tmp"
  mv "${script_install_path}/${script_name}.conf_tmp" "${script_install_path}/${script_name}.conf"
  get_status_message "$?"

  echo "[${caller}]: Running ${script_name} -V ..."
  chmod +x "${script_install_path}/${script_name}"
  ${script_name} -V
  get_status_message "$?"

}

# This function is used to check for script update. It will also prompt user to update the script if there is a new version available.
# Usage: check_update
# Example: check_update
check_update() {
  local script_name script_path caller temp_file script_install_path
  script_name="$(basename "${0}")"
  script_path="$(dirname "$(readlink -f "$0")")"
  caller="${script_name}->${FUNCNAME[0]}"
  script_install_path="/usr/local/maxicode/maxibuild"
  echo "[${caller}]: Checking ${script_name} for update..."
  temp_file="${TEMP_PATH}/${script_name}"
  # The github raw hosting will not be updated immediately after I push the update to github. Need to wait about 5 minutes
  if ! command -v curl &>/dev/null; then
    [[ "$(get_distro id)" == +(debian|ubuntu|centos|almalinux|rhel) ]] && apt-get install -y curl
  fi
  curl -H 'Cache-Control: no-cache' -so "${temp_file}" "https://raw.githubusercontent.com/sofibox/${script_name}_public/main/${script_name}"
  get_status_message "$?"
  available_version="$(awk -F'=' '/^_APP_VERSION=/{ print $2 }' "${temp_file}" | sed 's/\"//g')"
  this_version="${_APP_VERSION}"
  echo ""
  echo "Installed version is: v${this_version}"
  echo "Online version is: v${available_version}"
  echo ""
  if [[ "ok" == "$(echo | awk "(${available_version} > ${this_version}) { print \"ok\"; }")" ]]; then
    echo "[${caller}]: A new version of ${script_name} is available."

    read -r -p "[${caller}->input]: Do you want to update ${script_name} to version ${available_version}? [default:Y] [Y/n]: " response

    if [[ "$response" =~ ^([yY][eE][sS]|[yY])$ ]]; then
      script_update "${script_install_path}"
    else
      echo "[${caller}->cancel]: Operation aborted!"
      exit 0
    fi

  elif [[ "ok" == "$(echo | awk "(${available_version} == ${this_version}) { print \"ok\"; }")" ]]; then
    echo "[${caller}]: You are using the latest version of ${script_name}."
  else
    echo "[${caller}]: You are using a newer version of ${script_name} than the latest available."
  fi

  rm -f "${temp_file}"
}

# This function is used to check if given package is installed and install the package if it is not installed
# It will not do anything if the required package exist
# Usage: maxibuild [package(s)]
# Example: maxibuild curl wget git
get_status_message() {
  local retval
  retval="$1"
  if [[ "${retval}" -eq 0 ]]; then
    echo " [ OK ]"
  else
    echo " [ FAILED ]"
    exit 1
  fi
}

get_distro() {
  local arg distro_id distro_version distro_codename
  arg="$1"
  if [ -e /etc/os-release ]; then
    distro_id=$(awk -F= '$1 == "ID" {print $2}' /etc/os-release | LC_ALL=C tr '[:upper:]' '[:lower:]' | tr -d "\"")
    distro_version=$(awk -F= '$1 == "VERSION_ID" {print $2}' /etc/os-release | tr -d "\"")
    distro_codename=$(awk -F= '$1 == "VERSION_CODENAME" {print $2}' /etc/os-release | tr -d "\"")

  elif type lsb_release >/dev/null 2>&1; then
    distro_id=$(lsb_release -si | LC_ALL=C tr '[:upper:]' '[:lower:]')
    distro_version=$(lsb_release -sr)
    distro_codename=$(lsb_release -sc)
  else
    distro_id=$(uname -s)
    distro_version=$(uname -r)
    distro_codename=""
  fi
  if [ "${arg}" == "id" ]; then
    echo "${distro_id}"
  elif [ "${arg}" == "version" ]; then
    echo "${distro_version}"
  elif [ "${arg}" == "codename" ]; then
    echo "${distro_codename}"
  fi
}

# This function is used to convert an integer to ordinal number
# Usage: ordinal [number]
# Example: ordinal 1
# Output: 1st
to_ordinal() {
  local integer
  integer="$1"
  case "${integer}" in
  *1[0-9] | *[04-9]) echo "${integer}"th ;;
  *1) echo "${integer}"st ;;
  *2) echo "${integer}"nd ;;
  *3) echo "${integer}"rd ;;
  esac
}

maxibuild() {

  local caller required_cps missing_count

  caller="$(basename -- "$0")->${FUNCNAME[0]}"

  ((missing_count = 0))

  # Detect required packages
  read -ra required_cps <<<"$(echo "${INCLUDE_CPS}" | tr ',' ' ' | tr -d '"')"

  for required_cp in ${required_cps[*]}; do

    if [[ "${required_cp}" = +(mail|linode-cli|ipcalc|maxipi|maxiaide|maxigpg|maxiperm|maxida|dbxcli|ip|pstree|netstat|puttygen|grepaddr|gotify-server|gotify-client|blcheck|wp|wpcli|rclone|yq) ]]; then

      local cmd_status retval
      # Using command to obtain installation status
      command -v "${required_cp}" >/dev/null
      cmd_status="$?"

      [[ "${FORCE_INSTALL}" == "true" ]] && cmd_status=1

      if [[ "${cmd_status}" -eq 1 ]]; then
        ((missing_count++))
        echo ""

        if [[ "${FORCE_INSTALL}" == "true" ]]; then
          echo "[${caller}]: Notice, ${required_cp} will be installed in --force mode"
        else
          echo "[${caller}]: Warning, the required command ${required_cp} is missing!"
        fi
        echo ""

        # This prevents error if we never run apt-get update when the apt cache is expired
        # When the first missing package is triggered, then we display warning message,
        # and for this first time, we trigger update command to refresh the expired apt cache

        if [[ "${missing_count}" -eq 1 ]]; then
          echo "[${caller}]: Running system update for the first missing command ..."
          if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
            apt-get -qq -y update
          elif [[ "$(get_distro id)" == +(centos|fedora|rhel|almalinux|rocklylinux) ]]; then
            dnf -q -y update
          fi
          get_status_message "$?"
          echo ""

          # Check if git is installed (it is necessary)
          if ! command -v git >/dev/null; then
            echo "[${caller}]: Warning, git is missing!"
            echo ""
            echo "[${caller}]: Installing git ..."
            if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
              apt-get -qq -y install git
            elif [[ "$(get_distro id)" == +(centos|fedora|rhel|almalinux|rocklylinux) ]]; then
              dnf -q -y install git
            fi
            get_status_message "$?"
            echo ""
          fi

          # Check if curl is installed (it is necessary)
          if ! command -v curl >/dev/null; then
            echo "[${caller}]: Warning, curl is missing!"
            echo ""
            echo "[${caller}]: Installing curl ..."
            if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
              apt-get -qq -y install curl
            elif [[ "$(get_distro id)" == +(centos|fedora|rhel|almalinux|rocklylinux) ]]; then
              dnf -q -y install curl
            fi
            get_status_message "$?"
            echo ""
          fi

          # Check if wget is installed (it is necessary)
          if ! command -v wget >/dev/null; then
            echo "[${caller}]: Warning, wget is missing!"
            echo ""
            echo "[${caller}]: Installing wget ..."
            if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
              apt-get -qq -y install wget
            elif [[ "$(get_distro id)" == +(centos|fedora|rhel|almalinux|rocklylinux) ]]; then
              dnf -q -y install wget
            fi
            get_status_message "$?"
            echo ""
          fi

          # Check if unzip is installed (it is necessary)
          if ! command -v unzip >/dev/null; then
            echo "[${caller}]: Warning, unzip is missing!"
            echo ""
            echo "[${caller}]: Installing unzip ..."
            if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
              apt-get -qq -y install unzip
            elif [[ "$(get_distro id)" == +(centos|fedora|rhel|almalinux|rocklylinux) ]]; then
              dnf -q -y install unzip
            fi
            get_status_message "$?"
            echo ""
          fi

          # Check if tar is installed (it is necessary)
          if ! command -v tar >/dev/null; then
            echo "[${caller}]: Warning, tar is missing!"
            echo ""
            echo "[${caller}]: Installing tar ..."
            if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
              apt-get -qq -y install tar
            elif [[ "$(get_distro id)" == +(centos|fedora|rhel|almalinux|rocklylinux) ]]; then
              dnf -q -y install tar
            fi
            get_status_message "$?"
            echo ""
          fi
        fi

        echo "[${caller}]: ${missing_count}) Installing the $(to_ordinal "${missing_count}") missing command: ${required_cp} ..."
        echo ""

        # Package installation condition here
        if [[ "${required_cp}" == +(mail) ]]; then
          if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
            apt-get -y install bsd-mailx
          elif [[ "$(get_distro id)" == +(centos|almalinux|rockylinux) ]]; then
            apt-get -y install mail-utils
          fi
          get_status_message "$?"
          echo ""
        elif [[ "${required_cp}" == +(linode-cli) ]]; then

          if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
            apt-get -y install python3-pip
          elif [[ "$(get_distro id)" == +(centos|almalinux|rockylinux) ]]; then
            dnf -y install python3-pip
          fi
          pip3 install linode-cli --upgrade
        elif [[ "${required_cp}" == +(ipcalc) ]]; then

          local ipcalc_bin script_install_path
          script_install_path="/usr/local/opencode/ipcalc"
          ipcalc_bin="${script_install_path}/build/ipcalc"

          echo "[${caller}]: Removing the old ipcalc installation ..."
          if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
            apt-get -y remove ipcalc
          elif [[ "$(get_distro id)" == +(centos|almalinux|rockylinux) ]]; then
            dnf -y remove ipcalc
          fi

          get_status_message "$?"
          echo ""

          echo "[${caller}]: Removing the old ipcalc directory"
          rm -rf "${script_install_path}" /usr/local/bin/ipcalc /usr/bin/ipcalc
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Install required packages to build ipcalc ..."
          apt-get -y install git gcc meson
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating an installation directory for ipcalc ..."
          mkdir -p "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Cloning the ipcalc repository ..."
          git clone https://github.com/sofibox/ipcalc.git "${script_install_path}"
          get_status_message "$?"
          echo ""

          # Change directory to script_install_path, if failed then exit with a message
          cd "${script_install_path}" || {
            echo "Failed to change directory to ${script_install_path}"
            exit 1
          }

          echo "[${caller}]: Configuring ipcalc build type ..."
          meson setup build --buildtype=release
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Building ipcalc ..."
          ninja -C build
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Giving execution permission to the ipcalc installation script ..."
          chmod +x ${ipcalc_bin}
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating a symbolic link to the ipcalc installation script ..."
          ln -s ${ipcalc_bin} /usr/local/bin
          get_status_message "$?"
          echo ""

          #echo "[${caller}]: Copying sample config file ..."
          #cp "${script_install_path}/ipcalc.conf.sample" "${script_install_path}/ipcalc.conf"
          #echo ""

          # echo "[${caller}]: Running ipcalc --version  ..."
          # ipcalc --version
          # get_status_message "$?"
          # retval=$?

          command -v "${required_cp}" &>/dev/null
          get_status_message "$?"

        elif [ "${required_cp}" == "maxipi" ]; then
          if [[ "$(get_distro id)" == +(debian|ubuntu|centos|almalinux) ]]; then
            local maxipi_bin script_install_path
            script_install_path="/usr/local/maxicode/maxipi"
            maxipi_bin="${script_install_path}/maxipi"

            echo "[${caller}]: Removing the old maxipi directory"
            rm -rf "${script_install_path}" /usr/local/bin/maxipi /usr/bin/maxipi
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Install required packages to build maxipi ..."
            apt-get -y install gcc meson
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for maxipi ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Cloning the maxipi repository ..."
            git clone https://github.com/sofibox/maxipi_public.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the maxipi installation script ..."
            chmod +x ${maxipi_bin}
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the maxipi installation script ..."
            ln -s ${maxipi_bin} /usr/local/bin
            get_status_message "$?"
            echo ""

            #echo "[${caller}]: Running maxipi --version  ..."
            #maxipi --version
            #get_status_message "$?"
            #retval=$?

            command -v "${required_cp}" &>/dev/null
            get_status_message "$?"
          fi
        elif [[ "${required_cp}" == "maxiaide" ]]; then
          if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
            local maxiaide_bin script_install_path
            script_install_path="/usr/local/maxicode/maxiaide"
            maxiaide_bin="${script_install_path}/maxiaide"

            echo "[${caller}]: Removing aide aide-common..."

            apt-get -y remove aide aide-common
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Purging aide aide-common..."
            apt-get -y purge aide-common
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Removing the old maxiaide directory"
            rm -rf "${script_install_path}" /usr/local/bin/maxiaide /usr/bin/maxiaide

            echo "[${caller}]: Install maxiaide required packages ..."
            apt-get -y install aide
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for maxiaide ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Cloning the maxiaide repository ..."
            git clone https://github.com/sofibox/maxiaide_public.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the maxiaide installation script ..."
            chmod +x ${maxiaide_bin}
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the maxiaide installation script ..."
            ln -s ${maxiaide_bin} /usr/local/bin
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Copying sample config file ..."
            cp "${script_install_path}/maxiaide.conf.sample" "${script_install_path}/maxiaide.conf"
            get_status_message "$?"
            echo ""

            #echo "[${caller}]: Running maxiaide --version  ..."
            #maxiaide --version
            #get_status_message "$?"
            #retval=$?

            # Extra steps for Debian
            if [ -f /etc/cron.daily/aide ]; then
              echo "[${caller}]: Removing /etc/cron.daily/aide ..."
              rm -fv /etc/cron.daily/aide
              get_status_message "$?"
            fi

            command -v "${required_cp}" &>/dev/null
            get_status_message "$?"

          fi
        elif [[ "${required_cp}" == "maxigpg" ]]; then
          if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
            local maxigpg_bin script_install_path
            script_install_path="/usr/local/maxicode/maxigpg"
            maxigpg_bin="${script_install_path}/maxigpg"

            echo "[${caller}]: Removing GPG ..."
            apt-get -y remove gpg
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Removing the old maxigpg directory"
            rm -rf "${script_install_path}" /usr/local/bin/maxigpg /usr/bin/maxigpg
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Install maxigpg required packages ..."
            apt-get -y install gpg
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for maxigpg ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Cloning the maxigpg repository ..."
            git clone https://github.com/sofibox/maxigpg_public.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the maxigpg installation script ..."
            chmod +x ${maxigpg_bin}
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the maxigpg installation script ..."
            ln -s ${maxigpg_bin} /usr/local/bin
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Copying sample config file ..."
            cp "${script_install_path}/maxigpg.conf.sample" "${script_install_path}/maxigpg.conf"
            get_status_message "$?"
            echo ""

            #echo "[${caller}]: Running maxigpg --version  ..."
            #maxigpg --version
            #get_status_message "$?"
            #retval=$?

            command -v "${required_cp}" &>/dev/null
            get_status_message "$?"

          fi
        elif [[ "${required_cp}" == "maxiperm" ]]; then
          if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
            local maxiperm_bin perm_bin script_install_path
            script_install_path="/usr/local/maxicode/maxiperm"
            maxiperm_bin="${script_install_path}/maxiperm"
            perm_bin="${script_install_path}/perm"

            echo "[${caller}]: Removing the old maxiperm directory"
            rm -rf "${script_install_path}" /usr/local/bin/maxiperm /usr/bin/maxiperm /usr/local/bin/perm /usr/bin/perm
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for maxiperm ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Cloning the maxiperm repository ..."
            git clone https://github.com/sofibox/maxiperm_public.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the maxiperm installation script ..."
            chmod +x ${maxiperm_bin}
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the maxiperm installation script ..."
            ln -s ${maxiperm_bin} /usr/local/bin
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the perm installation script ..."
            chmod +x ${perm_bin}
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the perm installation script ..."
            ln -s ${perm_bin} /usr/local/bin
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Copying sample config file ..."
            cp "${script_install_path}/maxiperm.conf.sample" "${script_install_path}/maxiperm.conf"
            get_status_message "$?"
            echo ""

            # echo "[${caller}]: Running maxiperm --version  ..."
            # maxiperm --version
            # get_status_message "$?"
            # retval=$?

            command -v "${required_cp}" &>/dev/null
            get_status_message "$?"
          fi
        elif [[ "${required_cp}" == "maxida" ]]; then
          if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
            local maxida_bin dacli_bin script_install_path
            script_install_path="/usr/local/maxicode/maxida"
            maxida_bin="${script_install_path}/maxida"
            dacli_bin="${script_install_path}/dacli"

            echo "[${caller}]: Removing the old maxida directory"
            rm -rf "${script_install_path}" /usr/local/bin/maxida /usr/bin/maxida /usr/local/bin/dacli /usr/bin/dacli
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for maxida ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Cloning the maxida repository ..."
            git clone https://github.com/sofibox/maxida_public.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the maxida installation script ..."
            chmod +x ${maxida_bin}
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the maxida installation script ..."
            ln -s ${maxida_bin} /usr/local/bin
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the dacli installation script ..."
            chmod +x ${dacli_bin}
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the dacli installation script ..."
            ln -s ${dacli_bin} /usr/local/bin
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Copying sample config file ..."
            cp "${script_install_path}/maxida.conf.sample" "${script_install_path}/maxida.conf"
            get_status_message "$?"
            echo ""

            # echo "[${caller}]: Running maxida --version  ..."
            # maxida --version
            # get_status_message "$?"
            # retval=$?

            command -v "${required_cp}" &>/dev/null
            get_status_message "$?"
          fi
        elif [ "${required_cp}" == "dbxcli" ]; then
          if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
            local dbxcli_bin script_install_path
            script_install_path="/usr/local/opencode/dbxcli"
            dbxcli_bin="${script_install_path}/dbxcli"
            dropbox_uploader_bin="${script_install_path}/dropbox_uploader.sh"

            echo "[${caller}]: Removing the old dbxcli directory"
            rm -rf "${script_install_path}" /usr/local/bin/dbxcli /usr/bin/dbxcli
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for dbxcli ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Cloning the dbxcli repository ..."
            git clone https://github.com/sofibox/dbxcli.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the ${dropbox_uploader_bin} installation script ..."
            chmod +x "${dropbox_uploader_bin}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the dbxcli installation script ..."
            chmod +x "${dbxcli_bin}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the dbxcli installation script ..."
            ln -s "${dbxcli_bin}" /usr/local/bin
            get_status_message "$?"
            echo ""

            # echo "[${caller}]: Running dbxcli version  ..."
            # dbxcli version
            # get_status_message "$?"
            # retval=$?

            command -v "${required_cp}" &>/dev/null
            get_status_message "$?"
          fi

        elif [[ "${required_cp}" == "ip" ]]; then
          [[ "$(get_distro id)" == +(debian|ubuntu) ]] && apt-get -y install iproute2

          command -v "${required_cp}" &>/dev/null
          get_status_message "$?"
        elif [[ "${required_cp}" == "pstree" ]]; then
          [[ "$(get_distro id)" == +(debian|ubuntu|centos|almalinux|rockylinux) ]] && apt-get -y install psmisc

          command -v "${required_cp}" &>/dev/null
          get_status_message "$?"
        elif [[ "${required_cp}" == +(dig|nslookup) ]]; then
          [[ "$(get_distro id)" == +(debian|ubuntu) ]] && apt-get -y install dnsutils
          [[ "$(get_distro id)" == +(centos|almalinux|rockylinux) ]] && dnf -y install bind-utils

          command -v "${required_cp}" &>/dev/null
          get_status_message "$?"
        elif [[ "${required_cp}" == +(netstat) ]]; then
          [[ "$(get_distro id)" == +(debian|ubuntu|centos|almalinux|rockylinux) ]] && apt-get -y install net-tools

          command -v "${required_cp}" &>/dev/null
          get_status_message "$?"
        elif [[ "${required_cp}" == +(puttygen) ]]; then
          [[ "$(get_distro id)" == +(debian|ubuntu|centos|almalinux|rockylinux) ]] && apt-get -y install putty-tools
          command -v "${required_cp}" &>/dev/null
          get_status_message "$?"
        elif [[ "${required_cp}" == +(grepaddr) ]]; then
          if [[ "$(get_distro id)" == +(debian|ubuntu|centos|almalinux|rockylinux) ]]; then

            local grepaddr_bin script_install_path
            script_install_path="/usr/local/opencode/grepaddr"
            grepaddr_bin="${script_install_path}/grepaddr"

            echo "[${caller}]: Removing the old grepaddr directory"
            rm -rf "${script_install_path}" /usr/local/bin/grepaddr /usr/bin/grepaddr
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for grepaddr ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Cloning the grepaddr repository ..."
            git clone https://github.com/sofibox/grepaddr.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the grepaddr installation script ..."
            chmod +x "${grepaddr_bin}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the grepaddr installation script ..."
            ln -s "${grepaddr_bin}" /usr/local/bin
            get_status_message "$?"
            echo ""

          fi
          command -v "${required_cp}" &>/dev/null
          get_status_message "$?"
        elif [[ "${required_cp}" == +(gotify-server) ]]; then
          if [[ "$(get_distro id)" == +(debian|ubuntu|centos|almalinux|rockylinux) ]]; then
            local gotify_server_bin script_install_path
            script_install_path="/usr/local/opencode/gotify"

            gotify_server_system_username="gotify"
            gotify_server_system_group="gotify"
            gotify_server_platform="linux-amd64"
            gotify_server_app_name="gotify-server"
            gotify_server_service_name="gotify-server"
            gotify_server_service_location="/etc/systemd/system/${gotify_server_service_name}.service"
            gotify_server_app_path="${script_install_path}/server"
            gotify_server_bin="${gotify_server_app_path}/${gotify_server_app_name}"
            gotify_server_data_path="${gotify_server_app_path}/data"
            gotify_server_config="${gotify_server_app_path}/config.yml"
            gotify_server_latest_version=$(curl -s https://api.github.com/repos/gotify/server/releases/latest | grep "tag_name" | cut -d '"' -f 4)
            gotify_server_latest_url="https://github.com/gotify/server/releases/download/${gotify_server_latest_version}/gotify-${gotify_server_platform}.zip"

            if [ "${gotify_server_app_name}" == "gotify" ]; then
              echo "[${caller}]: Error, it is not recommend to use the gotify as the application name because you will have conflict with the gotify client. Please use something else such as gotify-server"
              exit 1
            fi

            echo "[${caller}]: Latest version of gotify server is ${gotify_server_latest_url}"
            echo ""

            if [[ "$(systemctl is-active htop)" == "active" ]]; then
              echo "[${caller}]: Stopping ${gotify_server_service_name}.service"
              systemctl stop "${gotify_server_service_name}.service"
              get_status_message "$?"
              echo ""
            fi

            echo "[${caller}]: Removing the old gotify server installation"

            rm -rf "${gotify_server_app_path}" /etc/systemd/system/"${gotify_server_service_name}.service" "/usr/local/bin/${gotify_server_app_name}"
            get_status_message "$?"
            echo ""

            if id -u "${gotify_server_system_username}" >/dev/null 2>&1; then
              echo "[${caller}]: Removing gotify server previous user ..."
              userdel -r "${gotify_server_system_username}"
              get_status_message "$?"
              echo ""
            fi

            if [[ $(getent group ${gotify_server_system_group}) ]]; then
              echo "[${caller}]: Removing gotify server previous group ..."
              groupdel "${gotify_server_system_group}"
              get_status_message "$?"
              echo ""
            fi

            echo "[${caller}]: Creating an installation directory for gotify server ..."
            mkdir -p "${gotify_server_app_path}"
            get_status_message "$?"
            echo ""

            cd "${gotify_server_app_path}" || {
              echo "[${caller}]: ERROR, could not change directory to ${gotify_server_app_path}"
              exit 1
            }
            echo "[${caller}]: Downloading the latest version of gotify server ..."

            wget -q "${gotify_server_latest_url}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Unzipping the gotify server ..."
            unzip -q "gotify-${gotify_server_platform}.zip"
            get_status_message "$?"
            echo ""

            # We don't need the zip file anymore
            echo "[${caller}]: Removing previous gotify server zip file ..."
            rm -rf "gotify-${gotify_server_platform}.zip"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Renaming the gotify server binary ..."
            mv "${gotify_server_app_path}/gotify-${gotify_server_platform}" "${gotify_server_bin}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Changing the owner of the gotify server binary to root:root ..."
            chown root:root "${gotify_server_bin}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the gotify server binary ..."
            chmod +x "${gotify_server_bin}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating gotify server symbolic link to /usr/local/bin ..."
            ln -s "${gotify_server_bin}" /usr/local/bin
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a gotify server group ..."
            groupadd -r "${gotify_server_system_group}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a gotify server user ..."
            useradd -M -d "${gotify_server_app_path}" -s /sbin/nologin -r -g "${gotify_server_system_group}" "${gotify_server_system_username}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Downloading the gotify server sample configuration file ..."
            wget https://raw.githubusercontent.com/gotify/server/master/config.example.yml -O "${gotify_server_config}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Changing the owner of the gotify server configuration file to root:root ..."
            chown root:root "${gotify_server_config}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Changing the permission of the gotify server configuration file to 644 ..."
            chmod 644 "${gotify_server_config}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a data directory for gotify server ..."
            mkdir -p "${gotify_server_data_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Changing the owner of the gotify server data directory to ${gotify_server_system_username}:${gotify_server_system_group} ..."
            chown -R "${gotify_server_system_username}:${gotify_server_system_group}" "${gotify_server_data_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Changing the permission of the gotify server data directory to 755 ..."
            chmod -R 755 "${gotify_server_data_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a systemd service file for gotify server at ${gotify_server_service_location} ..."

            {
              echo "[Unit]"
              echo "Description=Gotify Push Notification Server"
              echo "Documentation=https://gotify.net/docs"
              echo "After=network-online.target"
              echo "Wants=network-online.target systemd-networkd-wait-online.service"

              echo ""
              echo "[Service]"
              echo "Type=simple"
              echo "Restart=on-abnormal"
              echo "User=${gotify_server_system_username}"
              echo "Group=${gotify_server_system_group}"

              echo "WorkingDirectory=${gotify_server_app_path}"
              echo "ExecStart=${gotify_server_bin} -c ${gotify_server_config} -p ${gotify_server_data_path}"
              echo "ExecStop=kill $MAINPID"
              echo "ExecReload=kill -9 $MAINPID"

              echo ""
              echo "PrivateTmp=true"
              echo "ProtectSystem=full"
              echo "ReadWritePaths=${gotify_server_app_path}"
              echo "ReadWriteDirectories=${gotify_server_app_path}"
              echo "TimeoutStopSec=5s"

              echo ""
              echo "[Install]"
              echo "WantedBy=multi-user.target"
            } >"${gotify_server_service_location}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Changing the owner of the gotify server systemd service file to root:root ..."
            chown root:root "${gotify_server_service_location}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Changing the permission of the gotify server systemd service file to 644 ..."
            chmod 644 "${gotify_server_service_location}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Reloading systemd daemon ..."
            systemctl daemon-reload
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Enabling gotify server systemd service ..."
            systemctl enable "${gotify_server_service_name}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Starting gotify server systemd service ..."
            systemctl start "${gotify_server_service_name}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Checking the status of gotify server systemd service ..."
            systemctl --no-pager status "${gotify_server_service_name}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Stopping gotify server systemd service ..."
            systemctl stop "${gotify_server_service_name}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Checking whether gotify server command is available ..."
            command -v "${gotify_server_app_name}" &>/dev/null
            get_status_message "$?"

          fi
        elif [[ "${required_cp}" == +(gotify-client) ]]; then
          if [[ "$(get_distro id)" == +(debian|ubuntu|centos|almalinux|rockylinux) ]]; then

            local gotify_client_bin script_install_path gotify_client_latest_version gotify_client_latest_url
            script_install_path="/usr/local/opencode/gotify"

            gotify_client_app_name="gotify"

            if [ "${gotify_client_app_name}" == "gotify-server" ]; then
              echo "[${caller}]: Error, it is not recommend to use the gotify-server as the gotify client application name. Please use other name such as gotify-client or gotify."
              exit 1
            fi
            gotify_client_app_path="${script_install_path}/client"
            gotify_client_bin="${gotify_client_app_path}/${gotify_client_app_name}"

            gotify_client_latest_version="$(curl -s https://api.github.com/repos/gotify/cli/releases/latest | grep -oP '"tag_name": "\K(.*)(?=")')"
            gotify_client_latest_url="https://github.com/gotify/cli/releases/download/${gotify_client_latest_version}/gotify-cli-linux-amd64"

            echo "The latest version of gotify client is : ${gotify_client_latest_version}"

            echo "[${caller}]: Removing the old gotify client installation"

            rm -rf "${gotify_client_app_path}" "/usr/local/bin/${gotify_client_app_name}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for gotify client ..."
            mkdir -p "${gotify_client_app_path}"
            get_status_message "$?"
            echo ""

            cd "${gotify_client_app_path}" || {
              echo "[${caller}]: ERROR, could not change directory to ${gotify_client_app_path}"
              exit 1
            }

            echo "[${caller}]: Downloading gotify client (gotify-cli) ..."
            curl -Lo "${gotify_client_bin}" "${gotify_client_latest_url}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execute permission to gotify client (gotify-cli) ..."
            chmod +x "${gotify_client_bin}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link for gotify client (gotify-cli) ..."
            ln -s "${gotify_client_bin}" "/usr/local/bin/${gotify_client_app_name}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Checking whether gotify client command is available ..."
            command -v "${gotify_client_app_name}" &>/dev/null
            get_status_message "$?"

          fi
        elif [[ "${required_cp}" == +(blcheck) ]]; then
          if [[ "$(get_distro id)" == +(debian|ubuntu|centos|almalinux|rockylinux) ]]; then
            local blcheck_bin script_install_path

            script_install_path="/usr/local/opencode/blcheck"
            blcheck_bin="${script_install_path}/blcheck"

            echo "[${caller}]: Removing the old blcheck installation"
            rm -rf "${script_install_path}" "/usr/local/bin/blcheck" "/usr/bin/blcheck"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for blcheck ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Downloading blcheck from github ..."
            git clone https://github.com/sofibox/blcheck.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execute permission to blcheck ..."
            chmod +x "${blcheck_bin}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link for blcheck ..."
            ln -s "${blcheck_bin}" "/usr/local/bin/blcheck"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Copying the blcheck sample configuration file ..."
            cp "${script_install_path}/blcheck.conf.sample" "${script_install_path}/blcheck.conf"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Checking whether blcheck command is available ..."
            command -v blcheck &>/dev/null
            get_status_message "$?"

          fi

        elif [[ "${required_cp}" == +(wpcli|wp) ]]; then
          if [[ "$(get_distro id)" == +(debian|ubuntu|centos|almalinux|rockylinux) ]]; then
            local wpcli_bin script_install_path

            script_install_path="/usr/local/opencode/wpcli"
            wpcli_bin="${script_install_path}/wp"

            echo "[${caller}]: Removing the old wpcli installation"
            rm -rf "${script_install_path}" "/usr/local/bin/wp" "/usr/bin/wp" "/usr/local/bin/wpcli" "/usr/bin/wpcli"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for wpcli ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            cd "${script_install_path}" || {
              echo "[${caller}]: ERROR, could not change directory to ${script_install_path}"
              exit 1
            }

            echo "[${caller}]: Downloading wpcli ..."
            curl -O https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execute permission to wp-cli.phar ..."
            chmod +x wp-cli.phar
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Renaming wp-cli.phar to wp ..."
            mv wp-cli.phar wp
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link for wp ..."
            ln -s "${wpcli_bin}" "/usr/local/bin"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an alias symbolic link for wp as wpcli ..."
            ln -s "${wpcli_bin}" "/usr/local/bin/wpcli"
            get_status_message "$?"
            echo ""

            # If you don't have PHP CLI installed, you will get this error when you run the command wp
            # /usr/bin/env: 'php': No such file or directory
            # To fix this, install php-cli

            echo "WP-CLI has been installed. Please note that you need a PHP version >= 5.6.20 to run wp-cli"
            echo ""

            echo "[${caller}]: Checking whether wp command is available ..."
            command -v wp &>/dev/null
            get_status_message "$?"

          fi
        elif [[ "${required_cp}" == +(rclone) ]]; then
          if [[ "$(get_distro id)" == +(debian|ubuntu|centos|almalinux|rockylinux) ]]; then
            local install_temp_path

            install_temp_path="${TEMP_PATH}/rclone"

            echo "[${caller}]: Removing the old rclone installation"
            rm -rf "${install_temp_path}" "/usr/local/bin/rclone"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a temporary installation directory for rclone ..."
            mkdir -p "${install_temp_path}"
            get_status_message "$?"
            echo ""

            cd "${install_temp_path}" || {
              echo "[${caller}]: ERROR, could not change directory to ${install_temp_path}"
              exit 1
            }

            echo "[${caller}]: Downloading rclone ..."
            curl -O https://downloads.rclone.org/rclone-current-linux-amd64.zip
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Unzipping rclone ..."
            unzip rclone-current-linux-amd64.zip
            get_status_message "$?"
            echo ""

            cd rclone-*-linux-amd64 || {
              echo "[${caller}]: ERROR, could not change directory to rclone-*-linux-amd64"
              exit 1
            }

            echo "[${caller}]: Moving rclone to /usr/local/bin/rclone ..."
            mv rclone /usr/local/bin
            get_status_message "$?"
            echo ""

            cd "${install_temp_path}" || {
              echo "[${caller}]: ERROR, could not change directory to ${install_temp_path}"
              exit 1
            }

            echo "[${caller}]: Removing rclone installation temporary files ..."

            rm -rf "${install_temp_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execute permission to rclone ..."
            chmod +x /usr/local/bin/rclone
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Checking whether rclone command is available ..."
            command -v rclone &>/dev/null
            get_status_message "$?"

          fi
        elif [[ "${required_cp}" == +(yq) ]]; then
          if [[ "$(get_distro id)" == +(debian|ubuntu|centos|almalinux|rockylinux) ]]; then
            local install_temp_path arch_string yq_binary

            install_temp_path="${TEMP_PATH}/yq"
            arch_string=$(arch)
            yq_binary="yq_linux_amd64"

            if [[ "${arch_string}" == "x86_64" ]]; then
              yq_latest_version=$(curl -s https://api.github.com/repos/mikefarah/yq/releases/latest | grep "tag_name" | cut -d '"' -f 4)
              yq_latest_url="https://github.com/mikefarah/yq/releases/download/${yq_latest_version}/${yq_binary}"


              echo "[${caller}]: The latest version of yq is ${yq_latest_url}"

              echo "[${caller}]: Removing the old yq installation"
              rm -rf "${install_temp_path}" "/usr/local/bin/yq"
              get_status_message "$?"
              echo ""

              echo "[${caller}]: Creating a temporary installation directory for yq ..."
              mkdir -p "${install_temp_path}"
              get_status_message "$?"
              echo ""

              cd "${install_temp_path}" || {
                echo "[${caller}]: ERROR, could not change directory to ${install_temp_path}"
                exit 1
              }

              echo "[${caller}]: Downloading yq ..."
              wget -q "${yq_latest_url}" -O /usr/bin/yq
              get_status_message "$?"
              echo ""

              echo "[${caller}]: Giving execute permission to yq ..."
              chmod +x /usr/bin/yq
              get_status_message "$?"
              echo ""

              echo "[${caller}]: Removing yq installation temporary files ..."
              rm -rf "${install_temp_path}"
              get_status_message "$?"
              echo ""

              echo "[${caller}]: Checking whether yq command is available ..."
              command -v yq &>/dev/null
              get_status_message "$?"
            else
              echo "[${caller}]: ERROR, yq is not available for ${arch_string} architecture"
              exit 1
            fi

          fi

        else

          # Do normal distro installation
          if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
            apt-get -y install "${required_cp}"
          elif [[ "$(get_distro id)" == +(centos|almalinux|rockylinux) ]]; then
            dnf -y install "${required_cp}"
          fi
          command -v "${required_cp}" &>/dev/null
          get_status_message "$?"

        fi

      fi

    else

      local pkg_status retval
      pkg_status="$(dpkg-query -W --showformat='${db:Status-Status}' "${required_cp}" 2>&1)"
      retval="$?"

      if [[ "${FORCE_INSTALL}" == "true" ]]; then
        pkg_status="FORCE_INSTALL"
        retval=1
      fi

      if [[ "${pkg_status}" != "installed" || "${retval}" -ne 0 ]]; then
        ((missing_count++))
        echo ""
        if [[ "${FORCE_INSTALL}" == "true" ]]; then
          echo "[${caller}]: Notice, ${required_cp} will be installed in --force mode"
        else
          echo "[${caller}]: Warning, the package ${required_cp} is missing!"
        fi
        echo ""

        if [[ "${missing_count}" -eq 1 ]]; then
          echo "[${caller}]: Running system update for the first missing package ..."
          if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
            apt-get -qq -y update
            retval=$?
          elif [[ "$(get_distro id)" == +(centos|fedora|rhel|almalinux|rocklylinux) ]]; then
            dnf -q -y update
            retval=$?
          fi
          get_status_message "${retval}"
          echo ""
        fi

        echo "[${caller}]: ${missing_count}) Installing the $(to_ordinal "${missing_count}") missing package: ${required_cp} ..."
        echo "-------"
        echo ""
        # Add custom package to install here
        if [[ "${required_cp}" == +(bind-utils|dnsutils) ]]; then
          if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
            apt-get -y install dnsutils
            retval="$?"
          elif
            [[ "$(get_distro id)" == +(centos|almalinux|rockylinux|rhel) ]]
          then
            dnf -y install bind-utils
            retval="$?"
          fi
        else
          if [[ "$(get_distro id)" == +(debian|ubuntu) ]]; then
            apt-get -y install "${required_cp}"
            retval="$?"
          else
            dnf -y install "${required_cp}"
            retval="$?"
          fi
        fi

        get_status_message "${retval}"
        echo ""
      else
        :
        # echo "[${caller}]: The package ${required_cp} is installed."
      fi
    fi
  done

}

declare CALLER FORCE_INSTALL INCLUDE_CPS
SCRIPT_PATH="$(dirname "$(readlink -f "$0")")"
SCRIPT_NAME=$(basename -- "$0")
TEMP_PATH="/tmp"
CALLER="$(basename -- "$0")"

FORCE_INSTALL=false
INCLUDE_CPS=""

# If no argument is supplied we quit
if [[ $# -eq 0 ]]; then
  echo "Usage: $(basename -- "$0") [-f] [-i package1/command1,package2/command2,...] [-h]"
  echo "  -f: Force install of commands/packages"
  echo "  -i: Include commands/packages"
  echo "  -h: Show this help"
  exit 1
fi

while [ "$#" -gt 0 ]; do
  case "$1" in
  -h | --help)
    echo "Usage: $(basename -- "$0") [-f] [-i package1/command1,package2/command2,...] [-h]"
    echo "  -f: Force install of commands/packages"
    echo "  -i: Include commands/packages"
    echo "  -h: Show this help"
    exit 0
    ;;
  -v | -V | --version | version)
    echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
    echo ""
    echo "Info: ${_APP_INFO}"
    echo ""
    echo "Version: ${_APP_VERSION_STATUS}"
    echo ""
    echo "${_AUTHOR}"
    echo ""
    echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
    exit $?
    ;;
  # This will force both packages and commands installation
  -f | --force-install | --force)
    FORCE_INSTALL=true
    shift
    ;;
  -i | --include | --required | --install)
    INCLUDE_CPS="$2"
    shift 2
    ;;
  -u | --update | update)
    check_update
    exit $?
    ;;
  editself | edit-script | edit)
    nano -c "${SCRIPT_PATH}/${SCRIPT_NAME}"
    exit $?
    ;;
  --)
    break
    ;;
  *)
    echo "[${CALLER}]: Error, invalid  or option [ $1 ]. Use --help to see the valid actions or options"
    exit 1

    ;;
  esac

done

maxibuild "$@"
