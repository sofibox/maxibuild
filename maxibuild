#!/bin/bash
#"=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
# ==================================================
_APP_SPECIFIC_NAME="Maxibuild"
_APP_VERSION="0.4.0"
_APP_STATUS="alpha"
_APP_INFO="${_APP_SPECIFIC_NAME} is a bash script to manage packages."
_APP_VERSION_STATUS="${_APP_VERSION}-${_APP_STATUS}"
_AUTHOR="Author: Arafat Ali | Email: arafat@sofibox.com | (C) 2019-2023"
# ====================================================
# Usage:
# maxibuild --include "p1 p2 p3 p4" --force

# This script is used to update script from a remote repository based on a given path
# Usage: script_update [script_path]
# Example: script_update /opt/maxigpg_public/

# ================ shell config ====================
shopt -s extglob
# ================ shell config ====================

script_update() {
  local script_name script_path caller script_install_path current_configs new_configs

  script_name="$(basename "${0}")"
  script_path="$(dirname "$(readlink -f "$0")")"
  caller="${script_name}->${FUNCNAME[0]}"
  script_install_path="${1}"

  echo "[${caller}]: Updating $(basename -- "$0") to latest version ..."
  # CD to ${script_path} and if does not exist exit with error
  cd "${script_path}" || {
    echo "[${caller}]: ERROR, could not change directory to ${script_path}"
    exit 1
  }
  echo ""
  echo "START git update information:"
  git fetch --all
  get_status_message "$?"
  git reset --hard origin/main
  get_status_message "$?"
  echo "END git update information:"
  echo ""

  echo "[${caller}]: Updating ${script_name} configuration file ..."

  # This will add a new config variable into the config file if it does not exist
  # It will not disturb variable that already has value. So you do not need to reconfigure the script
  # If config contain invalid value like having no equal sign, it will also replace them with a new variable from sample config

  current_configs=$(grep -E '^[A-Za-z0-9_].+=.+$' "${script_install_path}/${script_name}.conf" | awk -F "=" '{print $1}')
  new_configs=$(grep -E '^[A-Za-z0-9_].+=.+$' "${script_install_path}/${script_name}.conf.sample" | awk -F "=" '{print $1}')

  for new_config in ${new_configs}; do
    if [[ ${current_configs} =~ ${new_config} ]]; then
      :
    else
      echo "Adding new config: ${new_config} into ${script_install_path}/${script_name}.conf"
      echo "${new_config}=\"\"" >>"${script_install_path}/${script_name}.conf"
      get_status_message "$?"
    fi
  done

  # Remove blank lines, comments and sort config file
  grep -E '^[A-Za-z0-9_].+=.+$' "${script_install_path}/${script_name}.conf" | sort >"${script_install_path}/${script_name}.conf_tmp"
  mv "${script_install_path}/${script_name}.conf_tmp" "${script_install_path}/${script_name}.conf"
  get_status_message "$?"

  echo "[${caller}]: Running ${script_name} -V ..."
  chmod +x "${script_install_path}/${script_name}"
  ${script_name} -V
  get_status_message "$?"

}

# This function is used to check for script update. It will also prompt user to update the script if there is a new version available.
# Usage: check_update
# Example: check_update
check_update() {
  local script_name script_path caller temp_file script_install_path
  script_name="$(basename "${0}")"
  script_path="$(dirname "$(readlink -f "$0")")"
  caller="${script_name}->${FUNCNAME[0]}"
  script_install_path="/usr/local/maxicode/maxibuild"
  echo "[${caller}]: Checking ${script_name} for update..."
  temp_file="${TEMP_PATH}/${script_name}"
  # The github raw hosting will not be updated immediately after I push the update to github. Need to wait about 5 minutes
  if ! command -v curl &>/dev/null; then
    [[ "$(get_distro id)" == @(debian|ubuntu|centos|almalinux|rhel) ]] && apt-get install -y curl
  fi
  curl -H 'Cache-Control: no-cache' -so "${temp_file}" "https://raw.githubusercontent.com/sofibox/${script_name}_public/main/${script_name}"
  get_status_message "$?"
  available_version="$(awk -F'=' '/^_APP_VERSION=/{ print $2 }' "${temp_file}" | sed 's/\"//g')"
  this_version="${_APP_VERSION}"
  echo ""
  echo "Installed version is: v${this_version}"
  echo "Online version is: v${available_version}"
  echo ""
  if [[ "ok" == "$(echo | awk "(${available_version} > ${this_version}) { print \"ok\"; }")" ]]; then
    echo "[${caller}]: A new version of ${script_name} is available."

    read -r -p "[${caller}->input]: Do you want to update ${script_name} to version ${available_version}? [default:Y] [Y/n]: " response

    if [[ "$response" =~ ^([yY][eE][sS]|[yY])$ ]]; then
      script_update "${script_install_path}"
    else
      echo "[${caller}->cancel]: Operation aborted!"
      exit 0
    fi

  elif [[ "ok" == "$(echo | awk "(${available_version} == ${this_version}) { print \"ok\"; }")" ]]; then
    echo "[${caller}]: You are using the latest version of ${script_name}."
  else
    echo "[${caller}]: You are using a newer version of ${script_name} than the latest available."
  fi

  rm -f "${temp_file}"
}

# This function is used to check if given package is installed and install the package if it is not installed
# It will not do anything if the required package exist
# Usage: maxibuild [package(s)]
# Example: maxibuild curl wget git
get_status_message() {
  local retval
  retval="$1"
  if [[ "${retval}" -eq 0 ]]; then
    echo " [ OK ]"
  else
    echo " [ FAILED ]"
    exit 1
  fi
}

get_distro() {
  local arg distro_id distro_version distro_codename
  arg="$1"
  if [ -e /etc/os-release ]; then
    distro_id=$(awk -F= '$1 == "ID" {print $2}' /etc/os-release | LC_ALL=C tr '[:upper:]' '[:lower:]' | tr -d "\"")
    distro_version=$(awk -F= '$1 == "VERSION_ID" {print $2}' /etc/os-release | tr -d "\"")
    distro_codename=$(awk -F= '$1 == "VERSION_CODENAME" {print $2}' /etc/os-release | tr -d "\"")

  elif type lsb_release >/dev/null 2>&1; then
    distro_id=$(lsb_release -si | LC_ALL=C tr '[:upper:]' '[:lower:]')
    distro_version=$(lsb_release -sr)
    distro_codename=$(lsb_release -sc)
  else
    distro_id=$(uname -s)
    distro_version=$(uname -r)
    distro_codename=""
  fi
  if [ "${arg}" == "id" ]; then
    echo "${distro_id}"
  elif [ "${arg}" == "version" ]; then
    echo "${distro_version}"
  elif [ "${arg}" == "codename" ]; then
    echo "${distro_codename}"
  fi
}

# This function is used to convert an integer to ordinal number
# Usage: ordinal [number]
# Example: ordinal 1
# Output: 1st
to_ordinal() {
  local integer
  integer="$1"
  case "${integer}" in
  *1[0-9] | *[04-9]) echo "${integer}"th ;;
  *1) echo "${integer}"st ;;
  *2) echo "${integer}"nd ;;
  *3) echo "${integer}"rd ;;
  esac
}

navigate_to() {

  local to_path="$1"

  if [[ "${to_path^^}" == +(PRE|PREVIOUS|OLDPATH|BACK|OLDPWD) ]]; then
    # OLD_PATH holds a previous path (see global variable of PREPATH in this script)
    echo "Navigating out into ${OLD_PATH} ..."
    to_path="${OLD_PATH}"
  else

    if [[ -z "${to_path}" ]]; then
      echo "Error, no path specified"
      exit 1
    fi

    if [[ ! -d "${to_path}" ]]; then
      echo "Error, the path ${to_path} does not exist"
      exit 1
    fi

    echo "Navigating into ${to_path} ..."
    OLD_PATH="${PWD}"
  fi

  cd "${to_path}" || {
    echo "Error, failed to enter into the directory ${to_path}"
    exit 1
  }

}

maxibuild() {

  local caller required_cps missing_count

  # To avoid error for current, we must always start from this path
  cd "${SCRIPT_PATH}" || {
    echo "Failed to change directory to ${SCRIPT_PATH}"
    exit 1
  }

  caller="$(basename -- "$0")->${FUNCNAME[0]}"

  ((missing_count = 0))

  # Detect required packages
  read -ra required_cps <<<"$(echo "${INCLUDE_CPS}" | tr ',' ' ' | tr -d '"')"

  for required_cp in ${required_cps[*]}; do
    # If the required package is a special command, we list it here
    # For example `puttygen` is a command and its package name is `putty-tools`. So if we want to install putty-tools, we can use `puttygen` as the command to install
    if [[ "${required_cp}" == @(mail|linode-cli|ipcalc|maxipi|maxiaide|maxigpg|maxiperm|maxida|maxilog|maxiwall|dbxcli|ip|pstree|netstat|puttygen|grepaddr|gotify-server|gotify-client|blcheck|wp|wpcli|rclone|yq|suricata_distro|suricata_backport|suricata|suricata_v6.0.9|suricata_v6.0.10|suricata_v7.0.0-rc1|lua|lua5.1|lua5.2|lua5.3|lua5.4|aipdb|greynoise|virustotal|mysqltuner) ]]; then

      local cmd_status retval
      # Using command to obtain installation status
      command -v "${required_cp}" >/dev/null
      cmd_status="$?"

      # START Special case
      if [[ "${required_cp}" == @(suricata|suricata_distro|suricata_backport|suricata_v6.0.9|suricata_v6.0.10|suricata_v7.0.0-rc1) ]]; then
        if command -v suricata &>/dev/null; then
          echo "[${caller}]: Suricata is already installed. Use --force to force install ${required_cp}"
          cmd_status=0
        fi
      fi
      # END Special case

      [[ "${FORCE_INSTALL}" == "true" ]] && cmd_status=1

      if [[ "${cmd_status}" -eq 1 ]]; then
        ((missing_count++))
        echo ""

        if [[ "${FORCE_INSTALL}" == "true" ]]; then
          echo "[${caller}]: Notice, ${required_cp} will be installed in --force mode"
        else
          echo "[${caller}]: Warning, the required command ${required_cp} is missing!"
        fi
        echo ""

        # This prevents error if we never run apt-get update when the apt cache is expired
        # When the first missing package is triggered, then we display warning message,
        # and for this first time, we trigger update command to refresh the expired apt cache

        if [[ "${missing_count}" -eq 1 ]]; then
          echo "[${caller}]: Running system update for the first missing command ..."
          if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
            apt-get -qq -y update
          elif [[ "$(get_distro id)" == @(centos|fedora|rhel|almalinux|rocklylinux) ]]; then
            dnf -q -y update
          fi
          get_status_message "$?"
          echo ""

          # Check if git is installed (it is necessary)
          if ! command -v git >/dev/null; then
            echo "[${caller}]: Warning, git is missing!"
            echo ""
            echo "[${caller}]: Installing git ..."
            if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
              apt-get -qq -y install git
            elif [[ "$(get_distro id)" == @(centos|fedora|rhel|almalinux|rocklylinux) ]]; then
              dnf -q -y install git
            fi
            get_status_message "$?"
            echo ""
          fi

          # Check if curl is installed (it is necessary)
          if ! command -v curl >/dev/null; then
            echo "[${caller}]: Warning, curl is missing!"
            echo ""
            echo "[${caller}]: Installing curl ..."
            if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
              apt-get -qq -y install curl
            elif [[ "$(get_distro id)" == @(centos|fedora|rhel|almalinux|rocklylinux) ]]; then
              dnf -q -y install curl
            fi
            get_status_message "$?"
            echo ""
          fi

          # Check if wget is installed (it is necessary)
          if ! command -v wget >/dev/null; then
            echo "[${caller}]: Warning, wget is missing!"
            echo ""
            echo "[${caller}]: Installing wget ..."
            if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
              apt-get -qq -y install wget
            elif [[ "$(get_distro id)" == @(centos|fedora|rhel|almalinux|rocklylinux) ]]; then
              dnf -q -y install wget
            fi
            get_status_message "$?"
            echo ""
          fi

          # Check if unzip is installed (it is necessary)
          if ! command -v unzip >/dev/null; then
            echo "[${caller}]: Warning, unzip is missing!"
            echo ""
            echo "[${caller}]: Installing unzip ..."
            if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
              apt-get -qq -y install unzip
            elif [[ "$(get_distro id)" == @(centos|fedora|rhel|almalinux|rocklylinux) ]]; then
              dnf -q -y install unzip
            fi
            get_status_message "$?"
            echo ""
          fi

          # Check if tar is installed (it is necessary)
          if ! command -v tar >/dev/null; then
            echo "[${caller}]: Warning, tar is missing!"
            echo ""
            echo "[${caller}]: Installing tar ..."
            if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
              apt-get -qq -y install tar
            elif [[ "$(get_distro id)" == @(centos|fedora|rhel|almalinux|rocklylinux) ]]; then
              dnf -q -y install tar
            fi
            get_status_message "$?"
            echo ""
          fi
        fi

        echo "[${caller}]: ${missing_count}) Installing the $(to_ordinal "${missing_count}") missing command: ${required_cp} ..."
        echo ""

        # Package installation condition here
        if [[ "${required_cp}" == @(mail) ]]; then
          if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
            apt-get -y install bsd-mailx
          elif [[ "$(get_distro id)" == @(centos|almalinux|rockylinux) ]]; then
            apt-get -y install mail-utils
          fi
          get_status_message "$?"
          echo ""
        elif [[ "${required_cp}" == @(linode-cli) ]]; then

          if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
            apt-get -y install python3-pip
          elif [[ "$(get_distro id)" == @(centos|almalinux|rockylinux) ]]; then
            dnf -y install python3-pip
          fi
          pip3 install linode-cli --upgrade
        elif [[ "${required_cp}" == @(ipcalc) ]]; then

          local ipcalc_bin script_install_path
          script_install_path="/usr/local/opencode/ipcalc"
          ipcalc_bin="${script_install_path}/build/ipcalc"

          echo "[${caller}]: Removing the old ipcalc installation ..."
          if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
            apt-get -y remove ipcalc
          elif [[ "$(get_distro id)" == @(centos|almalinux|rockylinux) ]]; then
            dnf -y remove ipcalc
          fi

          get_status_message "$?"
          echo ""

          echo "[${caller}]: Removing the old ipcalc directory"
          rm -rf "${script_install_path}" /usr/local/bin/ipcalc /usr/bin/ipcalc
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Install required packages to build ipcalc ..."
          apt-get -y install git gcc meson
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating an installation directory for ipcalc ..."
          mkdir -p "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Cloning the ipcalc repository ..."
          git clone https://github.com/sofibox/ipcalc.git "${script_install_path}"
          get_status_message "$?"
          echo ""

          # Change directory to script_install_path, if failed then exit with a message
          navigate_to "${script_install_path}"

          echo "[${caller}]: Configuring ipcalc build type ..."
          meson setup build --buildtype=release
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Building ipcalc ..."
          ninja -C build
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Giving execution permission to the ipcalc installation script ..."
          chmod +x ${ipcalc_bin}
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating a symbolic link to the ipcalc installation script ..."
          ln -s ${ipcalc_bin} /usr/local/bin
          get_status_message "$?"
          echo ""

          #echo "[${caller}]: Copying sample config file ..."
          #cp "${script_install_path}/ipcalc.conf.sample" "${script_install_path}/ipcalc.conf"
          #echo ""

          # echo "[${caller}]: Running ipcalc --version  ..."
          # ipcalc --version
          # get_status_message "$?"
          # retval=$?
          echo "[${caller}]: Checking if ipcalc is installed ..."
          command -v "${required_cp}" &>/dev/null
          get_status_message "$?"

        elif [ "${required_cp}" == "maxipi" ]; then
          if [[ "$(get_distro id)" == @(debian|ubuntu|centos|almalinux) ]]; then
            local maxipi_bin script_install_path
            script_install_path="/usr/local/maxicode/maxipi"
            maxipi_bin="${script_install_path}/maxipi"

            echo "[${caller}]: Removing the old maxipi directory"
            rm -rf "${script_install_path}" /usr/local/bin/maxipi /usr/bin/maxipi
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Install required packages to build maxipi ..."
            apt-get -y install gcc meson
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for maxipi ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Cloning the maxipi repository ..."
            git clone https://github.com/sofibox/maxipi_public.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the maxipi installation script ..."
            chmod +x ${maxipi_bin}
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the maxipi installation script ..."
            ln -s ${maxipi_bin} /usr/local/bin
            get_status_message "$?"
            echo ""

            #echo "[${caller}]: Running maxipi --version  ..."
            #maxipi --version
            #get_status_message "$?"
            #retval=$?
            echo "[${caller}]: Checking if maxipi is installed ..."
            command -v "${required_cp}" &>/dev/null
            get_status_message "$?"
          fi
        elif [[ "${required_cp}" == "maxiaide" ]]; then
          local maxiaide_bin script_install_path
          script_install_path="/usr/local/maxicode/maxiaide"
          maxiaide_bin="${script_install_path}/maxiaide"

          echo "[${caller}]: Removing the old maxiaide directory"
          rm -rf "${script_install_path}" /usr/local/bin/maxiaide /usr/bin/maxiaide

          if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then

            echo "[${caller}]: Removing aide aide-common..."

            apt-get -y remove aide aide-common
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Purging aide aide-common..."
            apt-get -y purge aide-common
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Install maxiaide required packages ..."
            apt-get -y install aide
            get_status_message "$?"
            echo ""
          elif [[ "$(get_distro id)" == @(centos|almalinux) ]]; then

            echo "[${caller}]: Removing aide ..."

            dnf -y remove aide
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Install maxiaide required packages ..."
            dnf -y install aide
            get_status_message "$?"
            echo ""

            # TODO make it support next time
            echo "[${caller}]: Note that maxiaide is not supported on this distribution yet."
          else
            echo "[${caller}]: ${required_cp} is not supported on this distribution"
            exit 1
          fi

          echo "[${caller}]: Creating an installation directory for maxiaide ..."
          mkdir -p "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Cloning the maxiaide repository ..."
          git clone https://github.com/sofibox/maxiaide_public.git "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Giving execution permission to the maxiaide installation script ..."
          chmod +x ${maxiaide_bin}
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating a symbolic link to the maxiaide installation script ..."
          ln -s ${maxiaide_bin} /usr/local/bin
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Copying sample config file ..."
          cp "${script_install_path}/maxiaide.conf.sample" "${script_install_path}/maxiaide.conf"
          get_status_message "$?"
          echo ""

          #echo "[${caller}]: Running maxiaide --version  ..."
          #maxiaide --version
          #get_status_message "$?"
          #retval=$?

          # Extra steps for Debian
          if [ -f /etc/cron.daily/aide ]; then
            echo "[${caller}]: Removing /etc/cron.daily/aide ..."
            rm -fv /etc/cron.daily/aide
            get_status_message "$?"
            echo ""
          fi

          echo "[${caller}]: Checking if ${required_cp} is installed ..."
          command -v "${required_cp}" &>/dev/null
          get_status_message "$?"
        elif [[ "${required_cp}" == "maxigpg" ]]; then
          if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
            local maxigpg_bin script_install_path
            script_install_path="/usr/local/maxicode/maxigpg"
            maxigpg_bin="${script_install_path}/maxigpg"

            echo "[${caller}]: Removing GPG ..."
            apt-get -y remove gpg
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Removing the old maxigpg directory"
            rm -rf "${script_install_path}" /usr/local/bin/maxigpg /usr/bin/maxigpg
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Install maxigpg required packages ..."
            apt-get -y install gpg
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for maxigpg ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Cloning the maxigpg repository ..."
            git clone https://github.com/sofibox/maxigpg_public.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the maxigpg installation script ..."
            chmod +x ${maxigpg_bin}
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the maxigpg installation script ..."
            ln -s ${maxigpg_bin} /usr/local/bin
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Copying sample config file ..."
            cp "${script_install_path}/maxigpg.conf.sample" "${script_install_path}/maxigpg.conf"
            get_status_message "$?"
            echo ""

            #echo "[${caller}]: Running maxigpg --version  ..."
            #maxigpg --version
            #get_status_message "$?"
            #retval=$?

            echo "[${caller}]: Checking if ${required_cp} is installed ..."
            command -v "${required_cp}" &>/dev/null
            get_status_message "$?"

          fi
        elif [[ "${required_cp}" == "maxiperm" ]]; then
          if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
            local maxiperm_bin perm_bin script_install_path
            script_install_path="/usr/local/maxicode/maxiperm"
            maxiperm_bin="${script_install_path}/maxiperm"
            perm_bin="${script_install_path}/perm"

            echo "[${caller}]: Removing the old maxiperm directory"
            rm -rf "${script_install_path}" /usr/local/bin/maxiperm /usr/bin/maxiperm /usr/local/bin/perm /usr/bin/perm
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for maxiperm ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Cloning the maxiperm repository ..."
            git clone https://github.com/sofibox/maxiperm_public.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the maxiperm installation script ..."
            chmod +x ${maxiperm_bin}
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the maxiperm installation script ..."
            ln -s ${maxiperm_bin} /usr/local/bin
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the perm installation script ..."
            chmod +x ${perm_bin}
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the perm installation script ..."
            ln -s ${perm_bin} /usr/local/bin
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Copying sample config file ..."
            cp "${script_install_path}/maxiperm.conf.sample" "${script_install_path}/maxiperm.conf"
            get_status_message "$?"
            echo ""

            # echo "[${caller}]: Running maxiperm --version  ..."
            # maxiperm --version
            # get_status_message "$?"
            # retval=$?
            echo "[${caller}]: Checking if ${required_cp} is installed ..."
            command -v "${required_cp}" &>/dev/null
            get_status_message "$?"
          fi
        elif [[ "${required_cp}" == "maxida" ]]; then
          if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
            local maxida_bin dacli_bin script_install_path
            script_install_path="/usr/local/maxicode/maxida"
            maxida_bin="${script_install_path}/maxida"
            dacli_bin="${script_install_path}/dacli"

            echo "[${caller}]: Removing the old maxida directory"
            rm -rf "${script_install_path}" /usr/local/bin/maxida /usr/bin/maxida /usr/local/bin/dacli /usr/bin/dacli
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for maxida ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Cloning the maxida repository ..."
            git clone https://github.com/sofibox/maxida_public.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the maxida installation script ..."
            chmod +x ${maxida_bin}
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the maxida installation script ..."
            ln -s ${maxida_bin} /usr/local/bin
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the dacli installation script ..."
            chmod +x ${dacli_bin}
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the dacli installation script ..."
            ln -s ${dacli_bin} /usr/local/bin
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Copying sample config file ..."
            cp "${script_install_path}/maxida.conf.sample" "${script_install_path}/maxida.conf"
            get_status_message "$?"
            echo ""

            # echo "[${caller}]: Running maxida --version  ..."
            # maxida --version
            # get_status_message "$?"
            # retval=$?
            echo "[${caller}]: Checking if ${required_cp} is installed ..."
            command -v "${required_cp}" &>/dev/null
            get_status_message "$?"
          fi
        elif [[ "${required_cp}" == "maxilog" ]]; then
          if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
            local maxilog_bin script_install_path
            script_install_path="/usr/local/maxicode/maxilog"
            maxilog_bin="${script_install_path}/maxilog"

            echo "[${caller}]: Removing the old maxilog directory"
            rm -rf "${script_install_path}" /usr/local/bin/maxilog /usr/bin/maxilog
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for maxilog ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Cloning the maxilog repository ..."
            git clone https://github.com/sofibox/maxilog_public.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the maxilog installation script ..."
            chmod +x ${maxilog_bin}
            get_status_message "$?"

            echo "[${caller}]: Creating a symbolic link to the maxilog installation script ..."
            ln -s ${maxilog_bin} /usr/local/bin
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Copying sample config file ..."
            cp "${script_install_path}/maxilog.conf.sample" "${script_install_path}/maxilog.conf"
            get_status_message "$?"

            echo "[${caller}]: Copying sample log_list.json file ..."
            cp "${script_install_path}/log_list.json.sample" "${script_install_path}/log_list.json"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Checking if ${required_cp} is installed ..."
            command -v "${required_cp}" &>/dev/null
            get_status_message "$?"
          fi

        elif [ "${required_cp}" == "dbxcli" ]; then
          if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
            local dbxcli_bin script_install_path
            script_install_path="/usr/local/opencode/dbxcli"
            dbxcli_bin="${script_install_path}/dbxcli"
            dropbox_uploader_bin="${script_install_path}/dropbox_uploader.sh"

            echo "[${caller}]: Removing the old dbxcli directory"
            rm -rf "${script_install_path}" /usr/local/bin/dbxcli /usr/bin/dbxcli
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for dbxcli ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Cloning the dbxcli repository ..."
            git clone https://github.com/sofibox/dbxcli.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the ${dropbox_uploader_bin} installation script ..."
            chmod +x "${dropbox_uploader_bin}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the dbxcli installation script ..."
            chmod +x "${dbxcli_bin}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the dbxcli installation script ..."
            ln -s "${dbxcli_bin}" /usr/local/bin
            get_status_message "$?"
            echo ""

            # echo "[${caller}]: Running dbxcli version  ..."
            # dbxcli version
            # get_status_message "$?"
            # retval=$?
            echo "[${caller}]: Checking if ${required_cp} is installed ..."
            command -v "${required_cp}" &>/dev/null
            get_status_message "$?"
          fi

        elif [[ "${required_cp}" == "ip" ]]; then
          [[ "$(get_distro id)" == @(debian|ubuntu) ]] && apt-get -y install iproute2

          echo "[${caller}]: Checking if ${required_cp} is installed ..."
          command -v "${required_cp}" &>/dev/null
          get_status_message "$?"
        elif [[ "${required_cp}" == "pstree" ]]; then
          [[ "$(get_distro id)" == @(debian|ubuntu|centos|almalinux|rockylinux) ]] && apt-get -y install psmisc

          echo "[${caller}]: Checking if ${required_cp} is installed ..."
          command -v "${required_cp}" &>/dev/null
          get_status_message "$?"
        elif [[ "${required_cp}" == @(dig|nslookup) ]]; then
          [[ "$(get_distro id)" == @(debian|ubuntu) ]] && apt-get -y install dnsutils
          [[ "$(get_distro id)" == @(centos|almalinux|rockylinux) ]] && dnf -y install bind-utils

          echo "[${caller}]: Checking if ${required_cp} is installed ..."
          command -v "${required_cp}" &>/dev/null
          get_status_message "$?"
        elif [[ "${required_cp}" == @(netstat) ]]; then
          [[ "$(get_distro id)" == @(debian|ubuntu|centos|almalinux|rockylinux) ]] && apt-get -y install net-tools

          echo "[${caller}]: Checking if ${required_cp} is installed ..."
          command -v "${required_cp}" &>/dev/null
          get_status_message "$?"
        elif [[ "${required_cp}" == @(puttygen) ]]; then
          [[ "$(get_distro id)" == @(debian|ubuntu|centos|almalinux|rockylinux) ]] && apt-get -y install putty-tools

          echo "[${caller}]: Checking if ${required_cp} is installed ..."
          command -v "${required_cp}" &>/dev/null
          get_status_message "$?"
        elif [[ "${required_cp}" == @(grepaddr) ]]; then
          if [[ "$(get_distro id)" == @(debian|ubuntu|centos|almalinux|rockylinux) ]]; then

            local grepaddr_bin script_install_path
            script_install_path="/usr/local/opencode/grepaddr"
            grepaddr_bin="${script_install_path}/grepaddr"

            echo "[${caller}]: Removing the old grepaddr directory"
            rm -rf "${script_install_path}" /usr/local/bin/grepaddr /usr/bin/grepaddr
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for grepaddr ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Cloning the grepaddr repository ..."
            git clone https://github.com/sofibox/grepaddr.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the grepaddr.py installation script ..."
            chmod +x "${grepaddr_bin}.py"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the grepaddr installation script ..."
            ln -s "${grepaddr_bin}.py" "/usr/local/bin"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the grepaddr.py alias called grepaddr ..."
            chmod +x "${grepaddr_bin}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link to the grepaddr.py alias called grepaddr ..."
            ln -s "${grepaddr_bin}" /usr/local/bin
            get_status_message "$?"
            echo ""

            echo "grepaddr has been installed. Please note that you need a python 3.6+ installation to use it."
            echo ""

            echo "[${caller}]: Checking if grepaddr is installed ..."
            command -v grepaddr &>/dev/null
            get_status_message "$?"

          fi

        elif

          [[ "${required_cp}" == @(gotify-server) ]]
        then
          if [[ "$(get_distro id)" == @(debian|ubuntu|centos|almalinux|rockylinux) ]]; then
            local script_install_path gotify_server_system_username gotify_server_system_group gotify_server_platform gotify_server_app_name gotify_server_service_name gotify_server_service_location \
              gotify_server_app_path gotify_server_bin gotify_server_data_path gotify_server_config gotify_server_latest_version gotify_server_latest_url
            script_install_path="/usr/local/opencode/gotify"

            gotify_server_system_username="gotify"
            gotify_server_system_group="gotify"
            gotify_server_platform="linux-amd64"
            gotify_server_app_name="gotify-server"
            gotify_server_service_name="gotify-server"
            gotify_server_service_location="/etc/systemd/system/${gotify_server_service_name}.service"
            gotify_server_app_path="${script_install_path}/server"
            gotify_server_bin="${gotify_server_app_path}/${gotify_server_app_name}"
            gotify_server_data_path="${gotify_server_app_path}/data"
            gotify_server_config="${gotify_server_app_path}/config.yml"
            gotify_server_latest_version=$(curl -s https://api.github.com/repos/gotify/server/releases/latest | grep "tag_name" | cut -d '"' -f 4)
            gotify_server_latest_url="https://github.com/gotify/server/releases/download/${gotify_server_latest_version}/gotify-${gotify_server_platform}.zip"

            if [ "${gotify_server_app_name}" == "gotify" ]; then
              echo "[${caller}]: Error, it is not recommend to use the gotify as the application name because you will have conflict with the gotify client. Please use something else such as gotify-server"
              exit 1
            fi

            echo "[${caller}]: Latest version of gotify server is ${gotify_server_latest_url}"
            echo ""

            if [[ "$(systemctl is-active htop)" == "active" ]]; then
              echo "[${caller}]: Stopping ${gotify_server_service_name}.service"
              systemctl stop "${gotify_server_service_name}.service"
              get_status_message "$?"
              echo ""
            fi

            echo "[${caller}]: Removing the old gotify server installation"

            rm -rf "${gotify_server_app_path}" /etc/systemd/system/"${gotify_server_service_name}.service" "/usr/local/bin/${gotify_server_app_name}"
            get_status_message "$?"
            echo ""

            if id -u "${gotify_server_system_username}" >/dev/null 2>&1; then
              echo "[${caller}]: Removing gotify server previous user ..."
              userdel -r "${gotify_server_system_username}"
              get_status_message "$?"
              echo ""
            fi

            if [[ $(getent group ${gotify_server_system_group}) ]]; then
              echo "[${caller}]: Removing gotify server previous group ..."
              groupdel "${gotify_server_system_group}"
              get_status_message "$?"
              echo ""
            fi

            echo "[${caller}]: Creating an installation directory for gotify server ..."
            mkdir -p "${gotify_server_app_path}"
            get_status_message "$?"
            echo ""

            navigate_to "${gotify_server_app_path}"

            echo "[${caller}]: Downloading the latest version of gotify server ..."

            wget -q "${gotify_server_latest_url}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Unzipping the gotify server ..."
            unzip -q "gotify-${gotify_server_platform}.zip"
            get_status_message "$?"
            echo ""

            # We don't need the zip file anymore
            echo "[${caller}]: Removing previous gotify server zip file ..."
            rm -rf "gotify-${gotify_server_platform}.zip"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Renaming the gotify server binary ..."
            mv "${gotify_server_app_path}/gotify-${gotify_server_platform}" "${gotify_server_bin}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Changing the owner of the gotify server binary to root:root ..."
            chown root:root "${gotify_server_bin}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execution permission to the gotify server binary ..."
            chmod +x "${gotify_server_bin}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating gotify server symbolic link to /usr/local/bin ..."
            ln -s "${gotify_server_bin}" /usr/local/bin
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a gotify server group ..."
            groupadd -r "${gotify_server_system_group}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a gotify server user ..."
            useradd -M -d "${gotify_server_app_path}" -s /sbin/nologin -r -g "${gotify_server_system_group}" "${gotify_server_system_username}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Downloading the gotify server sample configuration file ..."
            wget https://raw.githubusercontent.com/gotify/server/master/config.example.yml -O "${gotify_server_config}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Changing the owner of the gotify server configuration file to root:root ..."
            chown root:root "${gotify_server_config}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Changing the permission of the gotify server configuration file to 644 ..."
            chmod 644 "${gotify_server_config}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a data directory for gotify server ..."
            mkdir -p "${gotify_server_data_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Changing the owner of the gotify server data directory to ${gotify_server_system_username}:${gotify_server_system_group} ..."
            chown -R "${gotify_server_system_username}:${gotify_server_system_group}" "${gotify_server_data_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Changing the permission of the gotify server data directory to 755 ..."
            chmod -R 755 "${gotify_server_data_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a systemd service file for gotify server at ${gotify_server_service_location} ..."

            {
              echo "[Unit]"
              echo "Description=Gotify Push Notification Server"
              echo "Documentation=https://gotify.net/docs"
              echo "After=network-online.target"
              echo "Wants=network-online.target systemd-networkd-wait-online.service"

              echo ""
              echo "[Service]"
              echo "Type=simple"
              echo "Restart=on-abnormal"
              echo "User=${gotify_server_system_username}"
              echo "Group=${gotify_server_system_group}"

              echo "WorkingDirectory=${gotify_server_app_path}"
              echo "ExecStart=${gotify_server_bin} -c ${gotify_server_config} -p ${gotify_server_data_path}"
              echo "ExecStop=kill $MAINPID"
              echo "ExecReload=kill -9 $MAINPID"

              echo ""
              echo "PrivateTmp=true"
              echo "ProtectSystem=full"
              echo "ReadWritePaths=${gotify_server_app_path}"
              echo "ReadWriteDirectories=${gotify_server_app_path}"
              echo "TimeoutStopSec=5s"

              echo ""
              echo "[Install]"
              echo "WantedBy=multi-user.target"
            } >"${gotify_server_service_location}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Changing the owner of the gotify server systemd service file to root:root ..."
            chown root:root "${gotify_server_service_location}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Changing the permission of the gotify server systemd service file to 644 ..."
            chmod 644 "${gotify_server_service_location}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Reloading systemd daemon ..."
            systemctl daemon-reload
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Enabling gotify server systemd service ..."
            systemctl enable "${gotify_server_service_name}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Starting gotify server systemd service ..."
            systemctl start "${gotify_server_service_name}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Checking the status of gotify server systemd service ..."
            systemctl status "${gotify_server_service_name}" | cat
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Stopping gotify server systemd service ..."
            systemctl stop "${gotify_server_service_name}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Checking whether gotify server command is available ..."
            command -v "${gotify_server_app_name}" &>/dev/null
            get_status_message "$?"

          fi
        elif [[ "${required_cp}" == @(gotify-client) ]]; then
          if [[ "$(get_distro id)" == @(debian|ubuntu|centos|almalinux|rockylinux) ]]; then

            local gotify_client_bin script_install_path gotify_client_latest_version gotify_client_latest_url
            script_install_path="/usr/local/opencode/gotify"

            gotify_client_app_name="gotify"

            if [ "${gotify_client_app_name}" == "gotify-server" ]; then
              echo "[${caller}]: Error, it is not recommend to use the gotify-server as the gotify client application name. Please use other name such as gotify-client or gotify."
              exit 1
            fi
            gotify_client_app_path="${script_install_path}/client"
            gotify_client_bin="${gotify_client_app_path}/${gotify_client_app_name}"

            gotify_client_latest_version="$(curl -s https://api.github.com/repos/gotify/cli/releases/latest | grep -oP '"tag_name": "\K(.*)(?=")')"
            gotify_client_latest_url="https://github.com/gotify/cli/releases/download/${gotify_client_latest_version}/gotify-cli-linux-amd64"

            echo "The latest version of gotify client is : ${gotify_client_latest_version}"

            echo "[${caller}]: Removing the old gotify client installation"

            rm -rf "${gotify_client_app_path}" "/usr/local/bin/${gotify_client_app_name}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for gotify client ..."
            mkdir -p "${gotify_client_app_path}"
            get_status_message "$?"
            echo ""

            navigate_to "${gotify_client_app_path}"

            echo "[${caller}]: Downloading gotify client (gotify-cli) ..."
            curl -Lo "${gotify_client_bin}" "${gotify_client_latest_url}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execute permission to gotify client (gotify-cli) ..."
            chmod +x "${gotify_client_bin}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link for gotify client (gotify-cli) ..."
            ln -s "${gotify_client_bin}" "/usr/local/bin/${gotify_client_app_name}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Checking whether gotify client command is available ..."
            command -v "${gotify_client_app_name}" &>/dev/null
            get_status_message "$?"

          fi
        elif [[ "${required_cp}" == @(blcheck) ]]; then
          if [[ "$(get_distro id)" == @(debian|ubuntu|centos|almalinux|rockylinux) ]]; then
            local blcheck_bin script_install_path

            script_install_path="/usr/local/opencode/blcheck"
            blcheck_bin="${script_install_path}/blcheck"

            echo "[${caller}]: Removing the old blcheck installation"
            rm -rf "${script_install_path}" "/usr/local/bin/blcheck" "/usr/bin/blcheck"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for blcheck ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Downloading blcheck from github ..."
            git clone https://github.com/sofibox/blcheck.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execute permission to blcheck ..."
            chmod +x "${blcheck_bin}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link for blcheck ..."
            ln -s "${blcheck_bin}" "/usr/local/bin/blcheck"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Copying the blcheck sample configuration file ..."
            cp "${script_install_path}/blcheck.conf.sample" "${script_install_path}/blcheck.conf"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Checking whether blcheck command is available ..."
            command -v blcheck &>/dev/null
            get_status_message "$?"

          fi

        elif [[ "${required_cp}" == @(wpcli|wp) ]]; then
          if [[ "$(get_distro id)" == @(debian|ubuntu|centos|almalinux|rockylinux) ]]; then
            local wpcli_bin script_install_path

            script_install_path="/usr/local/opencode/wpcli"
            wpcli_bin="${script_install_path}/wp"

            echo "[${caller}]: Removing the old wpcli installation"
            rm -rf "${script_install_path}" "/usr/local/bin/wp" "/usr/bin/wp" "/usr/local/bin/wpcli" "/usr/bin/wpcli"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for wpcli ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            navigate_to "${script_install_path}"

            echo "[${caller}]: Downloading wpcli ..."
            curl -O https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execute permission to wp-cli.phar ..."
            chmod +x wp-cli.phar
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Renaming wp-cli.phar to wp ..."
            mv wp-cli.phar wp
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link for wp ..."
            ln -s "${wpcli_bin}" "/usr/local/bin"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an alias symbolic link for wp as wpcli ..."
            ln -s "${wpcli_bin}" "/usr/local/bin/wpcli"
            get_status_message "$?"
            echo ""

            # If you don't have PHP CLI installed, you will get this error when you run the command wp
            # /usr/bin/env: 'php': No such file or directory
            # To fix this, install php-cli

            echo "WP-CLI has been installed. Please note that you need a PHP version >= 5.6.20 to run wp-cli"
            echo ""

            echo "[${caller}]: Checking whether wp command is available ..."
            command -v wp &>/dev/null
            get_status_message "$?"

          fi
        elif [[ "${required_cp}" == @(rclone) ]]; then
          if [[ "$(get_distro id)" == @(debian|ubuntu|centos|almalinux|rockylinux) ]]; then
            local install_temp_path

            install_temp_path="${TEMP_PATH}/rclone"

            echo "[${caller}]: Removing the old rclone installation"
            rm -rf "${install_temp_path}" "/usr/local/bin/rclone"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a temporary installation directory for rclone ..."
            mkdir -p "${install_temp_path}"
            get_status_message "$?"
            echo ""

            navigate_to "${install_temp_path}"

            echo "[${caller}]: Downloading rclone ..."
            curl -O https://downloads.rclone.org/rclone-current-linux-amd64.zip
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Unzipping rclone ..."
            unzip rclone-current-linux-amd64.zip
            get_status_message "$?"
            echo ""

            navigate_to rclone-*-linux-amd64

            echo "[${caller}]: Moving rclone to /usr/local/bin/rclone ..."
            mv rclone /usr/local/bin
            get_status_message "$?"
            echo ""

            navigate_to "${install_temp_path}"

            echo "[${caller}]: Removing rclone installation temporary files ..."

            rm -rf "${install_temp_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Giving execute permission to rclone ..."
            chmod +x /usr/local/bin/rclone
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Checking whether rclone command is available ..."
            command -v rclone &>/dev/null
            get_status_message "$?"

          fi
        elif [[ "${required_cp}" == @(yq) ]]; then
          if [[ "$(get_distro id)" == @(debian|ubuntu|centos|almalinux|rockylinux) ]]; then
            local install_temp_path arch_string yq_binary

            install_temp_path="${TEMP_PATH}/yq"
            arch_string=$(arch)
            yq_binary="yq_linux_amd64"

            if [[ "${arch_string}" == "x86_64" ]]; then
              yq_latest_version=$(curl -s https://api.github.com/repos/mikefarah/yq/releases/latest | grep "tag_name" | cut -d '"' -f 4)
              yq_latest_url="https://github.com/mikefarah/yq/releases/download/${yq_latest_version}/${yq_binary}"

              echo "[${caller}]: The latest version of yq is ${yq_latest_version}"

              echo "[${caller}]: Removing the old yq installation"
              rm -rf "${install_temp_path}" "/usr/local/bin/yq"
              get_status_message "$?"
              echo ""

              echo "[${caller}]: Creating a temporary installation directory for yq ..."
              mkdir -p "${install_temp_path}"
              get_status_message "$?"
              echo ""

              navigate_to "${install_temp_path}"

              echo "[${caller}]: Downloading yq ..."
              wget -q "${yq_latest_url}" -O /usr/local/bin/yq
              get_status_message "$?"
              echo ""

              echo "[${caller}]: Giving execute permission to yq ..."
              chmod +x /usr/local/bin/yq
              get_status_message "$?"
              echo ""

              echo "[${caller}]: Removing yq installation temporary files ..."
              rm -rf "${install_temp_path}"
              get_status_message "$?"
              echo ""

              echo "[${caller}]: Checking whether yq command is available ..."
              command -v yq &>/dev/null
              get_status_message "$?"
            else
              echo "[${caller}]: ERROR, yq is not available for ${arch_string} architecture"
              exit 1
            fi

          fi
        elif [[ "${required_cp}" == @(suricata|suricata_distro|suricata_backport|suricata_v6.0.9|suricata_v6.0.10|suricata_v7.0.0-rc1) ]]; then

          echo "[${caller}]: Removing apt source list backports for suricata ..."
          sed -i "/deb http:\/\/deb.debian.org\/debian .*.-backports main/d" /etc/apt/sources.list
          get_status_message "$?"
          echo ""

          if systemctl is-active --quiet suricata; then
            echo "[${caller}]: Stopping suricata service ..."
            systemctl stop suricata
            get_status_message "$?"
            echo ""
          fi

          echo "[${caller}]: Removing suricata existing installation ..."
          apt-get remove -y --purge suricata
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Cleaning up old dependencies ..."
          apt-get autoremove -y
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Removing all suricata leftover files ..."
          rm -rfv /usr/share/suricata /etc/suricata /var/lib/suricata /var/log/suricata \
            /usr/bin/suricata /usr/local/bin/suricata /etc/default/suricata /etc/init.d/suricata /etc/systemd/system/suricata.service \
            /lib/systemd/system/suricata.service
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Reloading systemd daemon ..."
          systemctl daemon-reload
          get_status_message "$?"
          echo ""

          # Latest version as Jan 14 2023 is 6.0.1
          if [[ "${required_cp}" == "suricata_distro" ]]; then
            echo "[${caller}]: Installing suricata from the distribution repository ..."
            if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
              apt-get install -y suricata
              get_status_message "$?"
              echo ""
            elif
              [[ "$(get_distro id)" == @(centos|almalinux|rockylinux) ]]
            then
              dnf install -y suricata
              get_status_message "$?"
              echo ""
            else
              echo "[${caller}]: ERROR, suricata distro installation is not available (or implemented) for $(get_distro id)"

            fi
          # Latest version as Jan 14 2023 is v6.0.9 for Debian 11
          elif [[ "${required_cp}" == "suricata_backport" ]]; then
            if [[ "$(get_distro codename)" == @(bullseye|buster) ]]; then
              echo "[${caller}]: Writing backports to /etc/apt/sources.list ..."
              # Only write this if it doesn't exist
              grep -q "deb http://deb.debian.org/debian $(get_distro codename)-backports main" /etc/apt/sources.list || {
                echo "deb http://deb.debian.org/debian $(get_distro codename)-backports main" >>/etc/apt/sources.list
              }
              get_status_message "$?"
              echo ""

              echo "[${caller}]: Updating the package lists ..."
              apt-get -y update
              get_status_message "$?"
              echo ""

              echo "[${caller}]: Installing suricata from the backports repository ..."
              apt-get install -y suricata -t "$(get_distro codename)-backports"
              get_status_message "$?"
              echo ""
            else
              echo "[${caller}]: ERROR, suricata backport installation is not available (or implemented) for $(get_distro codename)"
            fi
          # Manual version - As February 15 2023, the latest version is v6.0.10 STABLE and v.7.0.0 RC 1
          elif [[ "${required_cp}" == @(suricata|suricata_v6.0.9|suricata_v6.0.10|suricata_v7.0.0-rc1) ]]; then

            local suricata_download_url install_temp_path version
            install_temp_path="${HOME}/suricata_install"

            navigate_to "${SCRIPT_PATH}"

            # We need to make sure that yq is installed. If not install it
            if ! command -v yq &>/dev/null; then
              echo "[${caller}]: Notice, yq is missing. Installing yq ..."
              FORCE_INSTALL=true INCLUDE_CPS="yq" maxibuild
            fi

            # We need to make sure that lua is installed. If not install it
            if ! command -v lua &>/dev/null; then
              echo "[${caller}]: Notice, lua is missing. Installing lua ..."
              FORCE_INSTALL=true INCLUDE_CPS="lua" maxibuild
            fi

            # Get suricata latest version number without the v prefix

            if [[ "${required_cp}" == "suricata" ]]; then
              version="$(curl -sL https://api.github.com/repos/OISF/suricata/releases/latest | yq -r '.tag_name' | sed 's/^suricata-//')"
              if [[ -z "${version}" ]]; then
                echo "[${caller}]: ERROR, unable to get suricata latest version number"
                exit 1
              fi
            elif [[ "${required_cp}" == "suricata_v6.0.9" ]]; then
              version="6.0.9"
            elif [[ "${required_cp}" == "suricata_v6.0.10" ]]; then
              version="6.0.10"
            elif [[ "${required_cp}" == "suricata_v7.0.0-rc1" ]]; then
              version="7.0.0-rc1"
            fi

            suricata_download_url="https://www.openinfosecfoundation.org/download/suricata-${version}.tar.gz"

            echo "[${caller}]: Removing suricata previous installation temporary files ..."
            rm -rf "${install_temp_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating temporary directory for suricata installation ..."
            mkdir -p "${install_temp_path}"
            get_status_message "$?"
            echo ""

            if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
              echo "[${caller}]: Installing essential build tools ..."
              apt-get -y install make autoconf automake libtool
              get_status_message "$?"
              echo ""

              echo "[${caller}]: Installing suricata dependencies ..."
              # libpcre2-devel is required for suricata v7.0.0-beta1
              apt-get install -y libpcre3 libpcre3-dbg libpcre3-dev build-essential libpcap-dev libnet1-dev libyaml-0-2 libyaml-dev pkg-config zlib1g zlib1g-dev liblz4-dev libcap-ng-dev libcap-ng0 libmagic-dev libjansson-dev libnspr4-dev libnss3-dev libgeoip-dev liblua5.1-0-dev libhiredis-dev libevent-dev python3-yaml python3-distutils python3-pip libpcre2-dev
              get_status_message "$?"
              echo ""

            elif [[ "$(get_distro id)" == @(centos|almalinux|rockylinux) ]]; then
              echo "[${caller}]: Installing essential build tools ..."
              dnf install -y make autoconf automake libtool
              get_status_message "$?"
              echo ""

              # TODO this is not fully tested for rhel based distros
              # pcre2-devel is required for suricata v7.0.0-beta1
              echo "[${caller}]: Installing suricata dependencies ..."
              dnf install -y pcre-devel libpcap-devel libnet-devel libyaml-devel pkgconfig zlib-devel liblz4-devel libcap-ng-devel libcap-ng0 libmagic-devel jansson-devel nspr-devel nss-devel GeoIP-devel lua-devel hiredis-devel libevent-devel python3-yaml python3-distutils python3-pip pcre2-devel
              get_status_message "$?"
              echo ""

            fi

            navigate_to "${install_temp_path}"

            echo "[${caller}]: Installing suricata python dependencies ..."
            pip3 install PyYAML
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Installing rustc package from https://sh.rustup.rs ..."
            local rustup_install_temp_error
            rustup_install_temp_error=$(curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y 2>&1 | grep 'likely because of mounting /tmp')

            if [ -n "${rustup_install_temp_error}" ]; then
              local rustup_tmp_init
              rustup_tmp_init=$(echo "${rustup_install_temp_error}" | awk '{ print $3 }')
              echo "[${caller}]: Notice, rustup installation failed. Resolving the error of: ${rustup_install_temp_error}"
              echo "[${caller}]: Notice, rustup-init file is located at: ${rustup_tmp_init}"
              echo ""

              echo "[${caller}]: Copying ${rustup_tmp_init} file to ${install_temp_path}/rustup-init ..."
              cp "${rustup_tmp_init}" "${install_temp_path}/rustup-init"
              get_status_message "$?"
              echo ""

              # Give execute permission to rustup-init file
              echo "[${caller}]: Giving execute permission to rustup-init file ..."
              chmod +x "${install_temp_path}/rustup-init"
              get_status_message "$?"
              echo ""

              # Executing rustup-init file
              echo "[${caller}]: Executing rustup-init file ..."
              "${install_temp_path}/rustup-init" -y
            else
              echo "[${caller}]: Notice, rustup installation succeeded."
            fi

            echo "[${caller}]: Source rustc environment ..."
            source "${HOME}/.cargo/env"
            get_status_message "$?"
            echo ""

            navigate_to "${install_temp_path}"

            echo "[${caller}]: Downloading suricata latest version ..."
            curl -L "${suricata_download_url}" -o "${install_temp_path}/suricata.tar.gz"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Extracting suricata latest version ..."
            tar -xzf "${install_temp_path}/suricata.tar.gz" -C "${install_temp_path}"
            get_status_message "$?"
            echo ""

            navigate_to "${install_temp_path}/suricata-${version}"

            echo "[${caller}]: Configuring suricata ..."
            ./configure --libdir=/usr/lib --prefix=/usr/ --sysconfdir=/etc --localstatedir=/var --datarootdir=/usr/share --enable-lua
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Building suricata ..."
            make install-full
            get_status_message "$?"
            echo ""

            # Remove rustc package
            echo "[${caller}]: Removing rustc package ..."
            rustup self uninstall -y
            get_status_message "$?"
            echo ""

            # Removing suricata temporary files
            echo "[${caller}]: Removing suricata previous installation temporary files ..."
            rm -rf "${install_temp_path}"
            get_status_message "$?"
            echo ""

            # Make sure that the suricata configuration file is present
            # Normally it will be at /etc/suricata/suricata.yaml after installation
            if [[ ! -f /etc/suricata/suricata.yaml ]]; then
              echo "[${caller}]: Warning suricata configuration file is missing!"
              exit 1
            fi

            # Modify suricata configuration file from /etc/suricata/suricata.yaml
            echo "[${caller}]: Modifying suricata configuration file ..."

            # Get the ssh port from sshd_config and change the ssh port from suricata configuration file
            echo "[${caller}]: Getting ssh port from sshd_config ..."
            local ssh_port
            ssh_port=$(grep "^Port" /etc/ssh/sshd_config | cut -d' ' -f2)

            if [[ -z "${ssh_port}" ]]; then
              echo "[${caller}]: ERROR, could not get ssh port from sshd_config"
              exit 1
            fi

            # Setting the ssh port in suricata configuration file
            echo ""

            echo "[${caller}]: Setting the ssh port in suricata configuration file ..."
            yq eval --inplace '.vars.port-groups.SSH_PORTS = '"$ssh_port"'' /etc/suricata/suricata.yaml
            get_status_message "$?"
            echo ""

            # Disabling fast.log in suricata configuration file
            echo "[${caller}]: Disabling fast.log in suricata configuration file ..."
            yq eval --inplace '.outputs[] |= (select(has("fast")).fast.enabled = "no" | .)' /etc/suricata/suricata.yaml
            get_status_message "$?"
            echo ""

            # Disabling eve.json in suricata configuration file
            echo "[${caller}]: Disabling eve.json in suricata configuration file ..."
            yq eval --inplace '.outputs[] |= (select(has("eve-log")).eve-log.enabled = "no" | .)' /etc/suricata/suricata.yaml
            get_status_message "$?"
            echo ""

            # Disabling http.log in suricata configuration file
            echo "[${caller}]: Disabling http.log in suricata configuration file ..."

            yq eval --inplace '.outputs[] |= (select(has("http-log")).http-log.enabled = "no" | .)' /etc/suricata/suricata.yaml
            get_status_message "$?"
            echo ""

            # Disabling tls.log in suricata configuration file
            echo "[${caller}]: Disabling tls.log in suricata configuration file ..."
            yq eval --inplace '.outputs[] |= (select(has("tls-log")).tls-log.enabled = "no" | .)' /etc/suricata/suricata.yaml

            get_status_message "$?"
            echo ""

            # Disabling tls-store
            echo "[${caller}]: Disabling tls-store ..."
            yq eval --inplace '.outputs[] |= (select(has("tls-store")).tls-store.enabled = "no" | .)' /etc/suricata/suricata.yaml
            get_status_message "$?"
            echo ""

            # Disabling pcap-log
            echo "[${caller}]: Disabling pcap-log ..."
            yq eval --inplace '.outputs[] |= (select(has("pcap-log")).pcap-log.enabled = "no" | .)' /etc/suricata/suricata.yaml
            get_status_message "$?"
            echo ""

            # Disabling alert-debug
            echo "[${caller}]: Disabling alert-debug ..."
            yq eval --inplace '.outputs[] |= (select(has("alert-debug")).alert-debug.enabled = "no" | .)' /etc/suricata/suricata.yaml
            get_status_message "$?"
            echo ""

            # Disabling alert-prelude
            echo "[${caller}]: Disabling alert-prelude ..."
            yq eval --inplace '.outputs[] |= (select(has("alert-prelude")).alert-prelude.enabled = "no" | .)' /etc/suricata/suricata.yaml
            get_status_message "$?"
            echo ""

            # Disabling syslog
            echo "[${caller}]: Disabling syslog ..."
            yq eval --inplace '.outputs[] |= (select(has("syslog")).syslog.enabled = "no" | .)' /etc/suricata/suricata.yaml
            get_status_message "$?"
            echo ""

            # Disabling stats in suricata configuration file
            echo "[${caller}]: Disabling stats in suricata configuration file ..."
            yq eval --inplace '.outputs[] |= (select(has("stats")).stats.enabled = "no" | .)' /etc/suricata/suricata.yaml
            get_status_message "$?"
            echo ""

            # Disabling file-store
            echo "[${caller}]: Disabling file-store log ..."
            yq eval --inplace '.outputs[] |= (select(has("file-store")).file-store.enabled = "no" | .)' /etc/suricata/suricata.yaml
            get_status_message "$?"
            echo ""

            # Disabling tpc-data
            echo "[${caller}]: Disabling tpc-data ..."
            yq eval --inplace '.outputs[] |= (select(has("tcp-data")).tcp-data.enabled = "no" | .)' /etc/suricata/suricata.yaml
            get_status_message "$?"
            echo ""

            # Disabling http-body-data
            echo "[${caller}]: Disabling http-body-data ..."
            yq eval --inplace '.outputs[] |= (select(has("http-body-data")).http-body-data.enabled = "no" | .)' /etc/suricata/suricata.yaml
            get_status_message "$?"
            echo ""

            # Enabling lua output
            echo "[${caller}]: Enabling lua output ..."
            yq eval --inplace '.outputs[] |= (select(has("lua")).lua.enabled = "yes" | .)' /etc/suricata/suricata.yaml
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating lua script path /etc/suricata/lua-output ..."
            yq eval --inplace '.outputs[] |= (select(has("lua")).lua."scripts-dir" = "/etc/suricata/lua-output" | .)' /etc/suricata/suricata.yaml
            get_status_message "$?"
            echo ""

            # Make sure the lua-output directory exists
            echo "[${caller}]: Creating /etc/suricata/lua-output directory ..."
            mkdir -p /etc/suricata/lua-output
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating suricata rule path /var/lib/suricata/rules ..."
            yq eval --inplace '.default-rule-path = "/var/lib/suricata/rules"' /etc/suricata/suricata.yaml
            get_status_message "$?"
            echo ""

            # Make sure the rule directory exists
            echo "[${caller}]: Creating /var/lib/suricata/rules directory ..."
            mkdir -p /var/lib/suricata/rules
            get_status_message "$?"
            echo ""

            # Disabling stats
            echo "[${caller}]: Disabling stats ..."
            yq eval --inplace '.stats.enabled = "no"' /etc/suricata/suricata.yaml
            get_status_message "$?"
            echo ""

            # Writing suricata service file
            echo "[${caller}]: Writing suricata service file ..."
            {
              echo "# Debug level ---> -v: INFO | -vv: INFO+PERF | -vvv: INFO+PERF+CONFIG | -vvvv: INFO+PERF+CONFIG+DEBUG"
              echo "#D - means in daemon | -c means read config | --pidfile <file> means write pidfile on a file"
              echo ""
              echo "[Unit]"
              echo "Description=Suricata IDS/IPS daemon"
              echo "After=network.target network-online.target"
              echo "Requires=network-online.target"
              echo "Documentation=man:suricata(8) man:suricatasc(8)"
              echo "Documentation=https://suricata-ids.org/docs/"
              echo ""
              echo "[Service]"
              echo "Type=forking"
              echo "#Environment=LD_PRELOAD=/usr/lib/libtcmalloc_minimal.so.4"
              echo "PIDFile=/run/suricata.pid"
              echo "ExecStart=/usr/bin/suricata -vvv -D --af-packet -c /etc/suricata/suricata.yaml --pidfile /run/suricata.pid"
              echo "ExecReload=/usr/bin/suricatasc -c reload-rules ; /bin/kill -HUP $MAINPID"
              echo "ExecStop=/usr/bin/suricatasc -c shutdown"
              echo "Restart=on-failure"
              echo "#This is too strict we disable it"
              echo "#ProtectSystem=full"
              echo "#ProtectHome=true"
              echo "#ReadWritePaths=/usr/local/maxicode /usr/local/opencode"
              echo ""
              echo "[Install]"
              echo "WantedBy=multi-user.target"
            } >/etc/systemd/system/suricata.service
            get_status_message "$?"
            echo ""

          fi

          echo "[${caller}]: Enabling suricata service ..."
          systemctl enable suricata.service
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Starting suricata service ..."
          systemctl start suricata.service
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Checking suricata service status ..."
          systemctl status suricata.service | cat
          get_status_message "$?"
          echo ""

          # Stop suricata service (maxibuild should not run it)
          echo "[${caller}]: Stopping suricata service ..."
          systemctl stop suricata.service
          get_status_message "$?"
          echo ""

          # Enabling suricata 3rd party rules
          echo "[${caller}]: Enabling suricata oisf/trafficid ..."
          suricata-update enable-source oisf/trafficid
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Enabling suricata sslbl/ssl-fp-blacklist ..."
          suricata-update enable-source sslbl/ssl-fp-blacklist
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Enabling suricata sslbl/ja3-fingerprints ..."
          suricata-update enable-source sslbl/ja3-fingerprints
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Enabling suricata et/open ..."
          suricata-update enable-source et/open
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Enabling suricata etnetera/aggressive ..."
          suricata-update enable-source etnetera/aggressive
          get_status_message "$?"
          echo ""

          # Update suricata sources
          echo "[${caller}]: Updating suricata sources ..."
          suricata-update update-sources
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Updating suricata rules ..."
          suricata-update 2>&1 | grep -v 'Found duplicate rule SID'
          get_status_message "$?"
          echo ""

          # Start suricata service

          echo "[${caller}]: Starting suricata service ..."
          systemctl start suricata.service
          get_status_message "$?"
          echo ""
        elif [[ "${required_cp}" == @(maxiwall) ]]; then
          local maxiwall_bin script_install_path
          script_install_path="/usr/local/maxicode/maxiwall"
          maxiwall_bin="${script_install_path}/maxiwall"

          # Make sure suricata is installed, if not we install it

          if ! command -v suricata &>/dev/null; then
            echo "[${caller}]: Notice, suricata is missing. Installing suricata ..."
            INCLUDE_CPS="suricata" maxibuild
          fi

          navigate_to "${SCRIPT_PATH}"

          # Make sure luarocks is installed, if not we install it
          if ! command -v luarocks &>/dev/null; then
            echo "[${caller}]: Installing luarocks ..."
            if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
              apt-get install -y luarocks
              get_status_message "$?"
              echo ""
            elif [[ "$(get_distro id)" == @(centos|almalinux|rockylinux) ]]; then
              yum install -y luarocks
              get_status_message "$?"
              echo ""
            fi
          fi

          # Install lua dependencies
          # Check if dkjson is installed, if not we install it
          if ! luarocks list | grep '^dkjson' &>/dev/null; then
            echo "[${caller}]: Installing dkjson ..."
            luarocks install dkjson
            get_status_message "$?"
            echo ""
          fi

          # Check if luasocket is installed, if not we install it
          if ! luarocks list | grep '^luasocket' &>/dev/null; then
            echo "[${caller}]: Installing luasocket ..."
            luarocks install luasocket
            get_status_message "$?"
            echo ""
          fi

          echo "[${caller}]: Stopping suricata service ..."
          systemctl stop suricata.service
          get_status_message "$?"
          echo ""

          # Remove existing maxiwall installation
          echo "[${caller}]: Removing existing maxiwall installation ..."
          rm -rf "${script_install_path}" "/usr/local/bin/maxiwall" "/usr/bin/maxiwall"
          get_status_message "$?"
          echo ""

          # Creating maxiwall installation directory
          echo "[${caller}]: Creating maxiwall installation directory ..."
          mkdir -p "${script_install_path}"
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Cloning the maxiwall repository ..."
          git clone https://github.com/sofibox/maxiwall_public.git "${script_install_path}"
          get_status_message "$?"
          echo ""

          # Change directory to script_install_path, if failed then exit with a message
          navigate_to "${script_install_path}"

          echo "[${caller}]: Giving execute permission to maxiwall ..."
          chmod +x ${maxiwall_bin}
          get_status_message "$?"
          echo ""

          echo "[${caller}]: Creating a symbolic link for maxiwall ..."
          ln -s "${maxiwall_bin}" "/usr/local/bin"
          get_status_message "$?"

          echo "[${caller}]: Checking whether maxiwall command is available ..."
          command -v maxiwall &>/dev/null
          get_status_message "$?"

          # Running maxiwall init
          echo "[${caller}]: Running maxiwall init ..."
          maxiwall init
          get_status_message "$?"
          echo ""

          # At this point maxiwall will do the rest of the installation

        elif

          [[ "${required_cp}" == @(lua|lua5.1|lua5.2|lua5.3|lua5.4) ]]
        then
          if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
            local lua_installed_versions lua_latest_web_version lua_generic_version lua_select_version luarocks_version install_temp_path

            install_temp_path="${TEMP_PATH}/lua_install"

            # echo "[${caller}]: Removing installation files manually ..."
            # rm -rf /etc/alternatives/lua-compiler /etc/alternatives/lua-compiler-manual /etc/alternatives/lua-interpreter \
            #  /etc/alternatives/lua-manual /usr/bin/lua /usr/bin/luac /usr/share/man/man1/lua.1.gz /usr/share/man/man1/luac.1.gz \
            #  /var/lib/dpkg/alternatives/lua-compiler /var/lib/dpkg/alternatives/lua-interpreter \
            #  /usr/local/bin/lua /usr/local/bin/luac /usr/local/include/lauxlib.h /usr/local/include/lua.h \
            #  /usr/local/include/lua.hpp /usr/local/include/luaconf.h /usr/local/include/lualib.h /usr/local/lib/liblua.a \
            #  /usr/local/lib/lua /usr/local/share/lua /usr/local/share/man/man1/lua.1 /usr/local/share/man/man1/luac.1

            #get_status_message "$?"
            #echo ""
            # # These are common suricata versions for debian/ubuntu
            #lua_installed_versions=(5.4 5.3 5.2 5.1)

            # for i in "${lua_installed_versions[@]}"; do
            #   echo "[${caller}]: Removing lua${i} installation using apt-get ..."
            #   apt-get remove -y "lua${i}"
            #   get_status_message "$?"
            #   echo ""

            #   # If lua is not installed using distro we manually remove all the lua files

            #   echo "[${caller}]: Removing other lua installation files ..."
            #   rm -rf "/usr/bin/lua${i}" "/usr/bin/luac${i}" "/usr/share/doc/lua${i}" "/usr/share/man/man1/lua${i}.1.gz" \
            #     "/usr/share/man/man1/luac${i}.1.gz" "/var/lib/dpkg/info/lua${i}.list" "/var/lib/dpkg/info/lua${i}.md5sums" \
            #     "/var/lib/dpkg/info/lua${i}.postinst" "/var/lib/dpkg/info/lua${i}.prerm" "/usr/local/lib/lua/${i}" \
            #     "/usr/local/share/lua/${i}"
            #   get_status_message "$?"
            #   echo ""

            # done

            echo "[${caller}]: Installing development tools ..."
            apt-get install -y build-essential libreadline-dev
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Getting lua latest version from web ..."

            if [[ "${required_cp}" == @(lua5.1) ]]; then
              # Download only lua5.1
              lua_generic_version=5.1
              lua_select_version="5.1.5"
            elif [[ "${required_cp}" == @(lua5.2) ]]; then
              lua_generic_version=5.2
              lua_select_version="5.2.4"
            elif [[ "${required_cp}" == @(lua5.3) ]]; then
              lua_generic_version=5.3
              lua_select_version="5.3.6"
            elif [[ "${required_cp}" == @(lua5.4) ]]; then
              lua_generic_version=5.4
              lua_select_version="5.4.4"
            else # lua

              lua_select_version=$(curl -s http://www.lua.org/ftp/ | grep -o 'lua-[0-9]\.[0-9]\.[0-9]\.tar\.gz' | sed 's/lua-//' | sed 's/\.tar\.gz//' | sort -rV | head -n 1)
              lua_generic_version=$(echo "${lua_select_version}" | cut -d '.' -f 1,2)

              if [ -z "${lua_select_version}" ]; then
                echo "[${caller}]: Unable to get lua latest version from web"
                exit 1
              fi
            fi

            # Print lua generic version
            echo "[${caller}]: Lua generic version to be installed is ${lua_generic_version}"
            echo ""
            # Print lua version
            echo "[${caller}]: Lua version to be installed is ${lua_select_version}"
            echo ""

            echo "[${caller}]: Removing lua ${lua_generic_version} installation using apt-get ..."
            apt-get remove -y "lua${lua_generic_version}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Removing lua ${lua_generic_version} directories ..."
            rm -rf "/usr/local/bin/lua" "/usr/bin/lua" "/usr/local/bin/luac" "/usr/bin/luac" "/usr/local/bin/lua${lua_generic_version} /usr/bin/lua${lua_generic_version}" "/usr/local/bin/luac${lua_generic_version}" \
              "/usr/bin/luac${lua_generic_version}" "/usr/share/man/man1/${lua_generic_version}.1.gz" "/usr/share/man/man1/luac${lua_generic_version}.1.gz" "/var/lib/dpkg/info/lua${lua_generic_version}.list" \
              "/var/lib/dpkg/info/lua${lua_generic_version}.md5sums" "/var/lib/dpkg/info/lua${lua_generic_version}.postinst" "/var/lib/dpkg/info/lua${lua_generic_version}.prerm" "/usr/local/lib/lua/${lua_generic_version}" \
              "/usr/local/share/lua/${lua_generic_version}" "/usr/local/lua-${lua_generic_version}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Removing lua previous installation temporary files ..."
            rm -rf "${install_temp_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating lua temporary installation path ..."
            mkdir -p "${install_temp_path}"
            get_status_message "$?"
            echo ""

            navigate_to "${install_temp_path}"

            echo "[${caller}]: Downloading lua ${lua_select_version} ..."
            curl -R -O "https://www.lua.org/ftp/lua-${lua_select_version}.tar.gz"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Extracting lua ${lua_select_version} ..."
            tar zxf "lua-${lua_select_version}.tar.gz"
            get_status_message "$?"
            echo ""

            navigate_to "lua-${lua_select_version}"

            echo "[${caller}]: Running make linux test ..."
            make linux test
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Running make install ..."
            make install INSTALL_TOP="/usr/local/lua-${lua_select_version}"
            get_status_message "$?"
            echo ""

            # Create symlink for lua and luac binaries for specific version
            echo "[${caller}]: Creating lua symlink for specific version ..."
            ln -s "/usr/local/lua-${lua_select_version}/bin/lua" "/usr/local/bin/lua${lua_generic_version}"
            ln -s "/usr/local/lua-${lua_select_version}/bin/luac" "/usr/local/bin/luac${lua_generic_version}"
            get_status_message "$?"
            echo ""

            # This for main lua
            echo "[${caller}]: Creating lua symbolic links (for the last install of lua) ..."
            ln -s "/usr/local/lua-${lua_select_version}/bin/lua" "/usr/local/bin/lua"
            ln -s "/usr/local/lua-${lua_select_version}/bin/luac" "/usr/local/bin/luac"
            get_status_message "$?"
            echo ""

            navigate_to "${install_temp_path}"
            # luarocks installation
            echo "[$caller}]: Downloading luarocks ..."
            luarocks_version="3.8.0"
            curl -R -O "https://luarocks.github.io/luarocks/releases/luarocks-${luarocks_version}.tar.gz"
            get_status_message "$?"
            echo ""

            echo "[$caller}]: Extracting luarocks ..."
            tar zxf "luarocks-${luarocks_version}.tar.gz"
            get_status_message "$?"
            echo ""

            navigate_to "luarocks-${luarocks_version}"

            echo "[$caller}]: Running luarocks configure ..."
            ./configure --with-lua="/usr/local/lua-${lua_select_version}" --lua-version="${lua_generic_version}" --with-lua-include="/usr/local/lua-${lua_select_version}/include"
            get_status_message "$?"
            echo ""

            echo "[$caller}]: Running luarocks make ..."
            make build
            get_status_message "$?"
            echo ""

            echo "[$caller}]: Running luarocks install ..."
            make install
            get_status_message "$?"
            echo ""

            # Remove the temporary installation files
            echo "[${caller}]: Removing lua temporary installation files ..."
            rm -rf "${install_temp_path}"
            get_status_message "$?"
            echo ""

          fi
        elif [[ "${required_cp}" == @(aipdb) ]]; then
          if [[ "$(get_distro id)" == @(debian|ubuntu|centos|almalinux|rockylinux) ]]; then

            local aipdb_bin script_install_path

            script_install_path="/usr/local/opencode/aipdb"
            aipdb_bin="${script_install_path}/aipdb"

            echo "[${caller}]: Removing the old aipdb installation"
            rm -rf "${script_install_path}" "/usr/local/bin/aipdb" "/usr/bin/aipdb"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for aipdb ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Cloning the aipdb repository ..."
            git clone https://github.com/sofibox/aipdb.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            # Change directory to script_install_path, if failed then exit with a message
            navigate_to "${script_install_path}"

            echo "[${caller}]: Giving execute permission to aipdb ..."
            chmod +x ${aipdb_bin}
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link for aipdb ..."
            ln -s "${aipdb_bin}" "/usr/local/bin"
            get_status_message "$?"

            echo "[${caller}]: Checking whether aipdb command is available ..."
            command -v aipdb &>/dev/null
            get_status_message "$?"

          fi
        elif [[ "${required_cp}" == @(greynoise) ]]; then
          if [[ "$(get_distro id)" == @(debian|ubuntu|centos|almalinux|rockylinux) ]]; then

            local greynoise_bin script_install_path

            script_install_path="/usr/local/opencode/greynoise"
            greynoise_bin="${script_install_path}/greynoise"

            echo "[${caller}]: Removing the old greynoise installation"
            rm -rf "${script_install_path}" "/usr/local/bin/greynoise" "/usr/bin/greynoise"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for greynoise ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Cloning the greynoise repository ..."
            git clone https://github.com/sofibox/greynoise.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            # Change directory to script_install_path, if failed then exit with a message
            navigate_to "${script_install_path}"

            echo "[${caller}]: Giving execute permission to greynoise ..."
            chmod +x ${greynoise_bin}
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link for greynoise ..."
            ln -s "${greynoise_bin}" "/usr/local/bin"
            get_status_message "$?"

            echo "[${caller}]: Checking whether greynoise command is available ..."
            command -v greynoise &>/dev/null
            get_status_message "$?"

          fi

        elif
          [[ "${required_cp}" == @(virustotal) ]]
        then
          if [[ "$(get_distro id)" == @(debian|ubuntu|centos|almalinux|rockylinux) ]]; then

            local virustotal_bin script_install_path

            script_install_path="/usr/local/opencode/virustotal"
            virustotal_bin="${script_install_path}/virustotal"

            echo "[${caller}]: Removing the old virustotal installation"
            rm -rf "${script_install_path}" "/usr/local/bin/virustotal" "/usr/bin/virustotal"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for virustotal ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Cloning the virustotal repository ..."
            git clone https://github.com/sofibox/virustotal.git "${script_install_path}"
            get_status_message "$?"
            echo ""

            # Change directory to script_install_path, if failed then exit with a message
            navigate_to "${script_install_path}"

            echo "[${caller}]: Giving execute permission to virustotal ..."
            chmod +x ${virustotal_bin}
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link for virustotal ..."
            ln -s "${virustotal_bin}" "/usr/local/bin"
            get_status_message "$?"
          fi
          # TODO last
        elif [[ "${required_cp}" == @(mysqltuner) ]]; then
          if [[ "$(get_distro id)" == @(debian|ubuntu|centos|almalinux|rockylinux) ]]; then
            local script_install_path
            script_install_path="/usr/local/opencode/mysqltuner"

            echo "[${caller}]: Removing the old mysqltuner installation ..."
            rm -rf "${script_install_path}" "/usr/local/bin/mysqltuner" "/usr/bin/mysqltuner"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating an installation directory for mysqltuner ..."
            mkdir -p "${script_install_path}"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Downloading and setup mysqltuner ..."
            wget -qO- https://raw.githubusercontent.com/major/MySQLTuner-perl/master/mysqltuner.pl >"${script_install_path}/mysqltuner.pl"
            get_status_message "$?"
            echo ""

            # Downloading basic_passwords.txt
            echo "[${caller}]: Downloading basic_passwords.txt ..."
            wget -qO- https://raw.githubusercontent.com/major/MySQLTuner-perl/master/basic_passwords.txt >"${script_install_path}/basic_passwords.txt"
            get_status_message "$?"
            echo ""

            # Downloading vulnerabilities.csv
            echo "[${caller}]: Downloading vulnerabilities.csv ..."
            wget -qO- https://raw.githubusercontent.com/major/MySQLTuner-perl/master/vulnerabilities.csv >"${script_install_path}/vulnerabilities.csv"
            get_status_message "$?"
            echo ""

            # Change permission of myqltuner.pl
            echo "[${caller}]: Giving execute permission to mysqltuner ..."
            chmod +x "${script_install_path}/mysqltuner.pl"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Creating a symbolic link for mysqltuner ..."
            ln -s "${script_install_path}/mysqltuner.pl" "/usr/local/bin/mysqltuner"
            get_status_message "$?"
            echo ""

            echo "[${caller}]: Checking whether mysqltuner command is available ..."
            command -v mysqltuner &>/dev/null
            get_status_message "$?"

          fi

        else
          echo "[${caller}]: Installing ${required_cp} from the default repository ..."
          # Do normal distro installation
          if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
            apt-get -y install "${required_cp}"
            get_status_message "$?"
            echo ""
          elif [[ "$(get_distro id)" == @(centos|almalinux|rockylinux) ]]; then
            dnf -y install "${required_cp}"
            get_status_message "$?"
            echo ""
          fi

          echo "[${caller}]: Checking ${required_cp} installation ..."
          command -v "${required_cp}" &>/dev/null
          get_status_message "$?"
        fi
      fi
    else
      local pkg_status retval
      pkg_status="$(dpkg-query -W --showformat='${db:Status-Status}' "${required_cp}" 2>&1)"
      retval="$?"

      if [[ "${FORCE_INSTALL}" == "true" ]]; then
        pkg_status="FORCE_INSTALL"
        retval=1
      fi

      if [[ "${pkg_status}" != "installed" || "${retval}" -ne 0 ]]; then
        ((missing_count++))
        echo ""
        if [[ "${FORCE_INSTALL}" == "true" ]]; then
          echo "[${caller}]: Notice, ${required_cp} will be installed in --force mode"
        else
          echo "[${caller}]: Warning, the package ${required_cp} is missing!"
        fi
        echo ""

        if [[ "${missing_count}" -eq 1 ]]; then
          echo "[${caller}]: Running system update for the first missing package ..."
          if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
            apt-get -qq -y update
            retval=$?
          elif [[ "$(get_distro id)" == @(centos|fedora|rhel|almalinux|rocklylinux) ]]; then
            dnf -q -y update
            retval=$?
          fi
          get_status_message "${retval}"
          echo ""
        fi

        echo "[${caller}]: ${missing_count}) Installing the $(to_ordinal "${missing_count}") missing package: ${required_cp} ..."
        echo "-------"
        echo ""
        # Add custom package to install here
        if [[ "${required_cp}" == @(bind-utils|dnsutils) ]]; then
          if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
            apt-get -y install dnsutils
            retval="$?"
          elif
            [[ "$(get_distro id)" == @(centos|almalinux|rockylinux|rhel) ]]
          then
            dnf -y install bind-utils
            retval="$?"
          fi
        else
          if [[ "$(get_distro id)" == @(debian|ubuntu) ]]; then
            apt-get -y install "${required_cp}"
            retval="$?"
          else
            dnf -y install "${required_cp}"
            retval="$?"
          fi
        fi

        get_status_message "${retval}"
        echo ""
      else
        :
        # echo "[${caller}]: The package ${required_cp} is installed."
      fi
    fi
  done

}

declare CALLER FORCE_INSTALL INCLUDE_CPS
SCRIPT_PATH="$(dirname "$(readlink -f "$0")")"
SCRIPT_NAME=$(basename -- "$0")
TEMP_PATH="/tmp"
CALLER="$(basename -- "$0")"

OLD_PATH="${PWD}"
FORCE_INSTALL=false
INCLUDE_CPS=""

# If no argument is supplied we quit
if [[ $# -eq 0 ]]; then
  echo "Usage: $(basename -- "$0") [-f] [-i package1/command1,package2/command2,...] [-h]"
  echo "  -f: Force install of commands/packages"
  echo "  -i: Include commands/packages"
  echo "  -h: Show this help"
  exit 1
fi

while [ "$#" -gt 0 ]; do
  case "$1" in
  -h | --help)
    echo "Usage: $(basename -- "$0") [-f] [-i package1/command1,package2/command2,...] [-h]"
    echo "  -f: Force install of commands/packages"
    echo "  -i: Include commands/packages"
    echo "  -h: Show this help"
    exit 0
    ;;
  -v | -V | --version | version)
    echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
    echo ""
    echo "Info: ${_APP_INFO}"
    echo ""
    echo "Version: ${_APP_VERSION_STATUS}"
    echo ""
    echo "${_AUTHOR}"
    echo ""
    echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
    exit $?
    ;;
  # This will force both packages and commands installation
  -f | --force-install | --force | force-install | force)
    FORCE_INSTALL=true
    shift
    ;;
  -i | --include | --required | --install | include | required | install)
    INCLUDE_CPS="$2"
    shift 2
    ;;
  -u | --update | update)
    check_update
    exit $?
    ;;
  editself | edit-script | edit)
    nano -c "${SCRIPT_PATH}/${SCRIPT_NAME}"
    exit $?
    ;;
  test)
    echo "ok?"
    exit $?
    ;;
  --)
    break
    ;;
  *)
    echo "[${CALLER}]: Error, invalid  or option [ $1 ]. Use --help to see the valid actions or options"
    exit 1

    ;;
  esac

done

maxibuild "$@"
